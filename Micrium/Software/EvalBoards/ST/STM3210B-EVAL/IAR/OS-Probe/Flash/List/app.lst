###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         21/Dec/2020  05:02:38
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\app.c
#    Command line                 =
#        -f C:\Users\SHIMJA~1\AppData\Local\Temp\EW5B32.tmp
#        (C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\app.c
#        -lCN
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List
#        -o
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.4\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\\
#        -I
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\ports\arm-cortex-m3\generic\iar\\
#        -I
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\source\\
#        -I
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-lib\\
#        -I
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\\
#        -I
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\ARM-Cortex-M3\IAR\\
#        -I
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\cpu\st\stm32\inc\\
#        -I
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\BSP\\
#        -I
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source\\
#        -I
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32\\
#        -I
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source\\
#        -I
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II\\
#        -Ohz --use_c++_inline)
#    Locale                       =  C
#    List file                    =
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List\app.lst
#    Object file                  =
#        C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj\app.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __size_limit               =  32768|ARM.EW.LINKER
#
###############################################################################

C:\Users\shimjaeyeong\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\app.c
      1          /*
      2           *********************************************************************************************************
      3           *                                              TERM PROJECT
      4           *                          (C) Copyright 2020; Lee Seung Yun; Shim Jae Yeong
      5           *               Some codes are referenced below.
      6           * 
      7           *                                              EXAMPLE CODE
      8           *
      9           *                          (c) Copyright 2003-2006; Micrium, Inc.; Weston, FL
     10           *
     11           *               All rights reserved.  Protected by international copyright laws.
     12           *               Knowledge of the source code may NOT be used to develop a similar product.
     13           *               Please help us continue to provide the Embedded community with the finest
     14           *               software available.  Your honesty is greatly appreciated.
     15           *********************************************************************************************************
     16           */
     17          
     18          /*
     19           *********************************************************************************************************
     20           *
     21           *                             High Temperature Entrance Checking Technique
     22           *
     23           *                                     ST Microelectronics STM32
     24           *                                              with the
     25           *                                   STM3210B-EVAL Evaluation Board
     26           *
     27           * Filename      : app.c
     28           * Version       : V1.0
     29           * Programmer(s) : Lee Seung Yun, Shim Jae Yeong
     30           *********************************************************************************************************
     31           */
     32          
     33          /*
     34           *********************************************************************************************************
     35           *                                             INCLUDE FILES
     36           *********************************************************************************************************
     37           */
     38          
     39          #include <includes.h>
     40          #include <stm32f10x_gpio.h>
     41          #include <stm32f10x_rcc.h>
     42          #include <stm32f10x_i2c.h>
     43          #include <stm32f10x_adc.h>
     44          #include <stm32f10x_spi.h>
     45          #include <stm32f10x_tim.h>
     46          
     47          /*
     48           *********************************************************************************************************
     49           *                                            LOCAL DEFINES
     50           *********************************************************************************************************
     51           */
     52          
     53          /*
     54           *********************************************************************************************************
     55           *                                       LOCAL GLOBAL VARIABLES
     56           *********************************************************************************************************
     57           */
     58          
     59          // Task Stack (size: 128)

   \                                 In section .bss, align 4
     60          static OS_STK detectTaskStack[TASK_STK_SIZE];
     61          static OS_STK temperatureTaskStack[TASK_STK_SIZE];
     62          static OS_STK passTaskStack[TASK_STK_SIZE];
     63          static OS_STK denyTaskStack[TASK_STK_SIZE];
     64          static OS_STK checkTaskStack[TASK_STK_SIZE];
     65          
     66          // Message Que
     67          static OS_EVENT *temperQue;
     68          static void *msg[10];
     69          
     70          // Event Flags
     71          static OS_FLAG_GRP *flagGroup;
   \                     flagGroup:
   \        0x0                      DS8 4
   \        0x4                      DS8 4
   \        0x8                      DS8 4
   \        0xC                      DS8 512
   \      0x20C                      DS8 512
   \      0x40C                      DS8 512
   \      0x60C                      DS8 512
   \      0x80C                      DS8 512
     72          const static OS_FLAGS FLAG_INIT = 0;
     73          const static OS_FLAGS FLAG_DETECT = 1;
     74          const static OS_FLAGS FLAG_DETECT_NOT = 2;
     75          const static OS_FLAGS FLAG_TEMPER_NORMAL = 4;
     76          const static OS_FLAGS FLAG_TEMPER_HIGH = 8;
     77          const static OS_FLAGS FLAG_TEMPER_LOW = 16;
     78          
     79          // time
     80          static OS_EVENT *sem;
     81          static int count = 0;
     82          const static int TIME_COUNT = 9; // 100ms * 10 = 1초
     83          const static int DELAY_TIME = 100;

   \                                 In section .bss, align 4
   \        0x0                      DS8 4
     84          static int ADC_value = 0;
     85          
     86          
     87          #if ((APP_OS_PROBE_EN == DEF_ENABLED) &&  \
     88          	 (APP_PROBE_COM_EN == DEF_ENABLED) && \
     89          	 (PROBE_COM_STAT_EN == DEF_ENABLED))

   \                                 In section .bss, align 4
   \        0x0                      DS8 4
     90          static CPU_FP32 App_ProbeComRxPktSpd;

   \                                 In section .bss, align 4
   \        0x0                      DS8 4
     91          static CPU_FP32 App_ProbeComTxPktSpd;

   \                                 In section .bss, align 4
   \        0x0                      DS8 4
     92          static CPU_FP32 App_ProbeComTxSymSpd;

   \                                 In section .bss, align 4
   \        0x0                      DS8 4
     93          static CPU_FP32 App_ProbeComTxSymByteSpd;
     94          

   \                                 In section .bss, align 4
     95          static CPU_INT32U App_ProbeComRxPktLast;
   \                     App_ProbeComRxPktLast:
   \        0x0                      DS8 4
   \        0x4                      DS8 4
   \        0x8                      DS8 4
   \        0xC                      DS8 4
   \       0x10                      DS8 4
   \       0x14                      DS8 4
     96          static CPU_INT32U App_ProbeComTxPktLast;
     97          static CPU_INT32U App_ProbeComTxSymLast;
     98          static CPU_INT32U App_ProbeComTxSymByteLast;
     99          
    100          static CPU_INT32U App_ProbeComCtrLast;
    101          #endif
    102          
    103          #if (APP_OS_PROBE_EN == DEF_ENABLED)
    104          static CPU_INT32U App_ProbeCounts;

   \                                 In section .bss, align 1
   \        0x0                      DS8 1
    105          static CPU_BOOLEAN App_ProbeB1;
    106          
    107          #endif
    108          
    109          /*
    110           *********************************************************************************************************
    111           *                                      LOCAL FUNCTION PROTOTYPES
    112           *********************************************************************************************************
    113           */
    114          
    115          // Task function
    116          static void detectTask(void *p);
    117          static void temperTask(void *p);
    118          static void passTask(void *p);
    119          static void denyTask(void *p);
    120          static void checkTask(void *p);
    121          
    122          static void App_DispScr_SignOn(void);
    123          static void DispScr_TaskNames(void);
    124          
    125          static int readTemperature(void);
    126          static void stopAll();
    127          static void initAll();
    128          
    129          #if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    130          	 (APP_OS_PROBE_EN == DEF_ENABLED))
    131          static void App_InitProbe(void);
    132          #endif
    133          
    134          #if (APP_OS_PROBE_EN == DEF_ENABLED)
    135          static void App_ProbeCallback(void);
    136          #endif
    137          
    138          /*
    139           *********************************************************************************************************
    140           *                                                main()
    141           *
    142           * Description : This is the standard entry point for C code.  It is assumed that your code will call
    143           *               main() once you have performed all necessary initialization.
    144           *
    145           * Argument(s) : none.
    146           *
    147           * Return(s)   : none.
    148           *********************************************************************************************************
    149           */
    150          

   \                                 In section .text, align 4, keep-with-next
    151          int main(void)
    152          {
   \                     main: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB09C             SUB      SP,SP,#+112
    153          	CPU_INT08U os_err;
    154          
    155          	/* Disable all ints until we are ready to accept them.  */
    156          	BSP_IntDisAll();
   \        0x4   0x....'....        BL       BSP_IntDisAll
    157          
    158          	/* Initialize "uC/OS-II, The Real-Time Kernel".         */
    159          	OSInit();
   \        0x8   0x....'....        BL       OSInit
    160          
    161          	initAll();
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0xF44F 0x1000      MOV      R0,#+2097152
   \       0x12   0x....'....        BL       RCC_APB1PeriphClockCmd
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0xF44F 0x4080      MOV      R0,#+16384
   \       0x1C   0x....'....        BL       RCC_APB1PeriphClockCmd
   \       0x20   0x2101             MOVS     R1,#+1
   \       0x22   0x2004             MOVS     R0,#+4
   \       0x24   0x....'....        BL       RCC_APB1PeriphClockCmd
   \       0x28   0x2101             MOVS     R1,#+1
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0x....'....        BL       RCC_APB2PeriphClockCmd
   \       0x30   0x2101             MOVS     R1,#+1
   \       0x32   0xF44F 0x7000      MOV      R0,#+512
   \       0x36   0x....'....        BL       RCC_APB2PeriphClockCmd
   \       0x3A   0x2101             MOVS     R1,#+1
   \       0x3C   0x2008             MOVS     R0,#+8
   \       0x3E   0x....'....        BL       RCC_APB2PeriphClockCmd
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \       0x4A   0xF88D 0x1003      STRB     R1,[SP, #+3]
   \       0x4E   0x2203             MOVS     R2,#+3
   \       0x50   0xF88D 0x2002      STRB     R2,[SP, #+2]
   \       0x54   0x4669             MOV      R1,SP
   \       0x56   0x....'....        LDR.W    R5,??DataTable12  ;; 0x40010c00
   \       0x5A   0x4628             MOV      R0,R5
   \       0x5C   0x....'....        BL       GPIO_Init
   \       0x60   0x20C0             MOVS     R0,#+192
   \       0x62   0x211C             MOVS     R1,#+28
   \       0x64   0x....'....        BL       ??Subroutine0_0
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x68   0xF44F 0x7080      MOV      R0,#+256
   \       0x6C   0x....'....        BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x70   0x2118             MOVS     R1,#+24
   \       0x72   0xF88D 0x1003      STRB     R1,[SP, #+3]
   \       0x76   0x2203             MOVS     R2,#+3
   \       0x78   0xF44F 0x7400      MOV      R4,#+512
   \       0x7C   0xF88D 0x2002      STRB     R2,[SP, #+2]
   \       0x80   0xF8AD 0x4000      STRH     R4,[SP, #+0]
   \       0x84   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x88   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x8C   0xF44F 0x5080      MOV      R0,#+4096
   \       0x90   0x2103             MOVS     R1,#+3
   \       0x92   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \       0x96   0xF88D 0x1002      STRB     R1,[SP, #+2]
   \       0x9A   0x2210             MOVS     R2,#+16
   \       0x9C   0xF88D 0x2003      STRB     R2,[SP, #+3]
   \       0xA0   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0xA4   0xF44F 0x4060      MOV      R0,#+57344
   \       0xA8   0x....'....        BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0xAC   0xF44F 0x5180      MOV      R1,#+4096
   \       0xB0   0x4628             MOV      R0,R5
   \       0xB2   0x....'....        BL       GPIO_SetBits
   \       0xB6   0x2201             MOVS     R2,#+1
   \       0xB8   0xF88D 0x2060      STRB     R2,[SP, #+96]
   \       0xBC   0xF88D 0x2061      STRB     R2,[SP, #+97]
   \       0xC0   0x2100             MOVS     R1,#+0
   \       0xC2   0xF44F 0x2260      MOV      R2,#+917504
   \       0xC6   0x9219             STR      R2,[SP, #+100]
   \       0xC8   0x9117             STR      R1,[SP, #+92]
   \       0xCA   0x911A             STR      R1,[SP, #+104]
   \       0xCC   0x2201             MOVS     R2,#+1
   \       0xCE   0xF88D 0x206C      STRB     R2,[SP, #+108]
   \       0xD2   0xA917             ADD      R1,SP,#+92
   \       0xD4   0x....'....        LDR.W    R5,??DataTable12_1  ;; 0x40012400
   \       0xD8   0x4628             MOV      R0,R5
   \       0xDA   0x....'....        BL       ADC_Init
   \       0xDE   0x2304             MOVS     R3,#+4
   \       0xE0   0x2201             MOVS     R2,#+1
   \       0xE2   0x2108             MOVS     R1,#+8
   \       0xE4   0x4628             MOV      R0,R5
   \       0xE6   0x....'....        BL       ADC_RegularChannelConfig
   \       0xEA   0x2101             MOVS     R1,#+1
   \       0xEC   0x4628             MOV      R0,R5
   \       0xEE   0x....'....        BL       ADC_Cmd
   \       0xF2   0x4628             MOV      R0,R5
   \       0xF4   0x....'....        BL       ADC_ResetCalibration
   \                     ??main_0: (+1)
   \       0xF8   0x4628             MOV      R0,R5
   \       0xFA   0x....'....        BL       ADC_GetResetCalibrationStatus
   \       0xFE   0x2800             CMP      R0,#+0
   \      0x100   0xD1FA             BNE.N    ??main_0
   \      0x102   0x4628             MOV      R0,R5
   \      0x104   0x....'....        BL       ADC_StartCalibration
   \                     ??main_1: (+1)
   \      0x108   0x4628             MOV      R0,R5
   \      0x10A   0x....'....        BL       ADC_GetCalibrationStatus
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD1FA             BNE.N    ??main_1
   \      0x112   0x2101             MOVS     R1,#+1
   \      0x114   0x4628             MOV      R0,R5
   \      0x116   0x....'....        BL       ADC_SoftwareStartConvCmd
   \      0x11A   0xF64B 0x72FF      MOVW     R2,#+49151
   \      0x11E   0xF8AD 0x201A      STRH     R2,[SP, #+26]
   \      0x122   0x2100             MOVS     R1,#+0
   \      0x124   0xF8AD 0x1018      STRH     R1,[SP, #+24]
   \      0x128   0xF8AD 0x101C      STRH     R1,[SP, #+28]
   \      0x12C   0xF44F 0x6280      MOV      R2,#+1024
   \      0x130   0xF8AD 0x201E      STRH     R2,[SP, #+30]
   \      0x134   0xF44F 0x4180      MOV      R1,#+16384
   \      0x138   0xF8AD 0x1020      STRH     R1,[SP, #+32]
   \      0x13C   0xA906             ADD      R1,SP,#+24
   \      0x13E   0x....'....        LDR.W    R2,??DataTable12_2  ;; 0x186a0
   \      0x142   0x....'....        LDR.W    R5,??DataTable12_3  ;; 0x40005400
   \      0x146   0x9209             STR      R2,[SP, #+36]
   \      0x148   0x4628             MOV      R0,R5
   \      0x14A   0x....'....        BL       I2C_Init
   \      0x14E   0x2101             MOVS     R1,#+1
   \      0x150   0x4628             MOV      R0,R5
   \      0x152   0x....'....        BL       I2C_Cmd
   \      0x156   0x2147             MOVS     R1,#+71
   \      0x158   0xF8AD 0x1004      STRH     R1,[SP, #+4]
   \      0x15C   0xF644 0x621F      MOVW     R2,#+19999
   \      0x160   0xF8AD 0x2008      STRH     R2,[SP, #+8]
   \      0x164   0x2100             MOVS     R1,#+0
   \      0x166   0xF8AD 0x100A      STRH     R1,[SP, #+10]
   \      0x16A   0x2210             MOVS     R2,#+16
   \      0x16C   0xF8AD 0x2006      STRH     R2,[SP, #+6]
   \      0x170   0xA901             ADD      R1,SP,#+4
   \      0x172   0x....'....        LDR.W    R5,??DataTable12_4  ;; 0x40000800
   \      0x176   0x4628             MOV      R0,R5
   \      0x178   0x....'....        BL       TIM_TimeBaseInit
   \      0x17C   0x2160             MOVS     R1,#+96
   \      0x17E   0xF8AD 0x104C      STRH     R1,[SP, #+76]
   \      0x182   0x2201             MOVS     R2,#+1
   \      0x184   0xF8AD 0x204E      STRH     R2,[SP, #+78]
   \      0x188   0xF44F 0x71FA      MOV      R1,#+500
   \      0x18C   0xF8AD 0x1052      STRH     R1,[SP, #+82]
   \      0x190   0x2200             MOVS     R2,#+0
   \      0x192   0xF8AD 0x2054      STRH     R2,[SP, #+84]
   \      0x196   0xA913             ADD      R1,SP,#+76
   \      0x198   0x4628             MOV      R0,R5
   \      0x19A   0x....'....        BL       TIM_OC3Init
   \      0x19E   0x2101             MOVS     R1,#+1
   \      0x1A0   0x4628             MOV      R0,R5
   \      0x1A2   0x....'....        BL       TIM_Cmd
   \      0x1A6   0x2160             MOVS     R1,#+96
   \      0x1A8   0xF8AD 0x103C      STRH     R1,[SP, #+60]
   \      0x1AC   0x2201             MOVS     R2,#+1
   \      0x1AE   0xF8AD 0x203E      STRH     R2,[SP, #+62]
   \      0x1B2   0xF240 0x51DC      MOVW     R1,#+1500
   \      0x1B6   0xF8AD 0x1042      STRH     R1,[SP, #+66]
   \      0x1BA   0x2200             MOVS     R2,#+0
   \      0x1BC   0xF8AD 0x2044      STRH     R2,[SP, #+68]
   \      0x1C0   0xA90F             ADD      R1,SP,#+60
   \      0x1C2   0x4628             MOV      R0,R5
   \      0x1C4   0x....'....        BL       TIM_OC4Init
   \      0x1C8   0x2100             MOVS     R1,#+0
   \      0x1CA   0x4628             MOV      R0,R5
   \      0x1CC   0x....'....        BL       TIM_OC4PreloadConfig
   \      0x1D0   0x2101             MOVS     R1,#+1
   \      0x1D2   0x4628             MOV      R0,R5
   \      0x1D4   0x....'....        BL       TIM_ARRPreloadConfig
   \      0x1D8   0x2101             MOVS     R1,#+1
   \      0x1DA   0x4628             MOV      R0,R5
   \      0x1DC   0x....'....        BL       TIM_Cmd
   \      0x1E0   0xF44F 0x4140      MOV      R1,#+49152
   \      0x1E4   0xF8AD 0x1028      STRH     R1,[SP, #+40]
   \      0x1E8   0xF44F 0x7282      MOV      R2,#+260
   \      0x1EC   0xF44F 0x6100      MOV      R1,#+2048
   \      0x1F0   0xF8AD 0x102C      STRH     R1,[SP, #+44]
   \      0x1F4   0xF8AD 0x202A      STRH     R2,[SP, #+42]
   \      0x1F8   0xF8AD 0x4032      STRH     R4,[SP, #+50]
   \      0x1FC   0x2110             MOVS     R1,#+16
   \      0x1FE   0x2200             MOVS     R2,#+0
   \      0x200   0xF8AD 0x1034      STRH     R1,[SP, #+52]
   \      0x204   0xF8AD 0x202E      STRH     R2,[SP, #+46]
   \      0x208   0xF8AD 0x2030      STRH     R2,[SP, #+48]
   \      0x20C   0xF8AD 0x2036      STRH     R2,[SP, #+54]
   \      0x210   0xA90A             ADD      R1,SP,#+40
   \      0x212   0x....             LDR.N    R4,??DataTable12_5  ;; 0x40003800
   \      0x214   0x4620             MOV      R0,R4
   \      0x216   0x....'....        BL       SPI_Init
   \      0x21A   0x2101             MOVS     R1,#+1
   \      0x21C   0x4620             MOV      R0,R4
   \      0x21E   0x....'....        BL       SPI_Cmd
    162          
    163          	// Create Message Que, msg : 저장공간, 크기 : 10
    164          	//temperQue = (OS_EVENT *)OSQCreate(msg, 10);
    165          
    166          	// Create Event Flag
    167          	flagGroup = OSFlagCreate(FLAG_INIT, &os_err);
   \      0x222   0xA905             ADD      R1,SP,#+20
   \      0x224   0x2000             MOVS     R0,#+0
   \      0x226   0x....             LDR.N    R4,??DataTable12_6
   \      0x228   0x....'....        BL       OSFlagCreate
   \      0x22C   0x6020             STR      R0,[R4, #+0]
    168          
    169          	// Create semaphore
    170          	sem = OSSemCreate(0);
   \      0x22E   0x2000             MOVS     R0,#+0
   \      0x230   0x....'....        BL       OSSemCreate
   \      0x234   0x6060             STR      R0,[R4, #+4]
    171          
    172          	os_err = OSTaskCreateExt((void (*)(void *))detectTask,						   // Task가 수행할 함수, 사람의 존재 유/무를 알려주는 Task
    173          							 (void *)0,											   // Task로 넘겨줄 인자
    174          							 (OS_STK *)&detectTaskStack[TASK_STK_SIZE - 1],		   // Task가 할당될 Stack의 Top을 가리키는 주소
    175          							 (INT8U)TASK_DETECT_PRIO,							   // Task의 우선 순위 (MPT)
    176          							 (INT16U)TASK_DETECT_PRIO,							   // Task를 지칭하는 유일한 식별자, Task 갯수의 극복을 위해서 사용할 예정, 현재는 우선 순위와 같게끔 설정
    177          							 (OS_STK *)&detectTaskStack,						   // Task가 할당될 Stack의 마지막을 가리키는 주소, Stack 검사용으로 사용
    178          							 (INT32U)TASK_STK_SIZE,								   // Task Stack의 크기를 의미
    179          							 (void *)0,											   // Task Control Block 활용시 사용
    180          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK)); // Task 생성 옵션
   \      0x236   0x....'....        BL       ??Subroutine4_0
   \                     ??CrossCallReturnLabel_18: (+1)
   \      0x23A   0xF104 0x030C      ADD      R3,R4,#+12
   \      0x23E   0x2002             MOVS     R0,#+2
   \      0x240   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_3: (+1)
   \      0x244   0x2302             MOVS     R3,#+2
   \      0x246   0xF504 0x7202      ADD      R2,R4,#+520
   \      0x24A   0x....'....        ADR.W    R0,detectTask
   \      0x24E   0x....'....        BL       OSTaskCreateExt
   \      0x252   0x....'....        BL       ?Subroutine4
    181          
    182          	os_err = OSTaskCreateExt((void (*)(void *))temperTask, // 사람의 온도를 측정하여 통과할지 말지를 결정하는 Task
    183          							 (void *)0,
    184          							 (OS_STK *)&temperatureTaskStack[TASK_STK_SIZE - 1],
    185          							 (INT8U)TASK_TEMPER_PRIO,
    186          							 (INT16U)TASK_TEMPER_PRIO,
    187          							 (OS_STK *)&temperatureTaskStack,
    188          							 (INT32U)TASK_STK_SIZE,
    189          							 (void *)0,
    190          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \                     ??CrossCallReturnLabel_15: (+1)
   \      0x256   0xF504 0x7303      ADD      R3,R4,#+524
   \      0x25A   0x2001             MOVS     R0,#+1
   \      0x25C   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_4: (+1)
   \      0x260   0x2301             MOVS     R3,#+1
   \      0x262   0xF504 0x6281      ADD      R2,R4,#+1032
   \      0x266   0x....'....        ADR.W    R0,temperTask
   \      0x26A   0x....'....        BL       OSTaskCreateExt
   \      0x26E   0xF88D 0x0014      STRB     R0,[SP, #+20]
    191          
    192          	os_err = OSTaskCreateExt((void (*)(void *))passTask, // 정상체온인 사람은 통과를 허가하는 Task
    193          							 (void *)0,
    194          							 (OS_STK *)&passTaskStack[TASK_STK_SIZE - 1],
    195          							 (INT8U)TASK_PASS_PRIO,
    196          							 (INT16U)TASK_PASS_PRIO,
    197          							 (OS_STK *)&passTaskStack,
    198          							 (INT32U)TASK_STK_SIZE,
    199          							 (void *)0,
    200          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \      0x272   0x2100             MOVS     R1,#+0
   \      0x274   0x2003             MOVS     R0,#+3
   \      0x276   0x9004             STR      R0,[SP, #+16]
   \      0x278   0x2280             MOVS     R2,#+128
   \      0x27A   0xF204 0x430C      ADDW     R3,R4,#+1036
   \      0x27E   0x2007             MOVS     R0,#+7
   \      0x280   0x9202             STR      R2,[SP, #+8]
   \      0x282   0x9301             STR      R3,[SP, #+4]
   \      0x284   0x9000             STR      R0,[SP, #+0]
   \      0x286   0x9103             STR      R1,[SP, #+12]
   \      0x288   0x2307             MOVS     R3,#+7
   \      0x28A   0xF504 0x62C1      ADD      R2,R4,#+1544
   \      0x28E   0x....'....        ADR.W    R0,passTask
   \      0x292   0x....'....        BL       OSTaskCreateExt
   \      0x296   0x....'....        BL       ?Subroutine4
    201          
    202          	os_err = OSTaskCreateExt((void (*)(void *))denyTask, // 비정상체온인 사람은 통과를 불허하는 Task
    203          							 (void *)0,
    204          							 (OS_STK *)&denyTaskStack[TASK_STK_SIZE - 1],
    205          							 (INT8U)TASK_DENY_PRIO,
    206          							 (INT16U)TASK_DENY_PRIO,
    207          							 (OS_STK *)&denyTaskStack,
    208          							 (INT32U)TASK_STK_SIZE,
    209          							 (void *)0,
    210          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \                     ??CrossCallReturnLabel_16: (+1)
   \      0x29A   0xF204 0x630C      ADDW     R3,R4,#+1548
   \      0x29E   0x2008             MOVS     R0,#+8
   \      0x2A0   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_5: (+1)
   \      0x2A4   0x2308             MOVS     R3,#+8
   \      0x2A6   0xF604 0x0208      ADDW     R2,R4,#+2056
   \      0x2AA   0x....'....        ADR.W    R0,denyTask
   \      0x2AE   0x....'....        BL       OSTaskCreateExt
   \      0x2B2   0x....'....        BL       ?Subroutine4
    211          
    212          	os_err = OSTaskCreateExt((void (*)(void *))checkTask, // 알림 장치 작동 중지하는 Task
    213          							 (void *)0,
    214          							 (OS_STK *)&checkTaskStack[TASK_STK_SIZE - 1],
    215          							 (INT8U)TASK_CHECK_PRIO,
    216          							 (INT16U)TASK_CHECK_PRIO,
    217          							 (OS_STK *)&checkTaskStack,
    218          							 (INT32U)TASK_STK_SIZE,
    219          							 (void *)0,
    220          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \                     ??CrossCallReturnLabel_17: (+1)
   \      0x2B6   0xF604 0x030C      ADDW     R3,R4,#+2060
   \      0x2BA   0x2006             MOVS     R0,#+6
   \      0x2BC   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_6: (+1)
   \      0x2C0   0x2306             MOVS     R3,#+6
   \      0x2C2   0xF604 0x2208      ADDW     R2,R4,#+2568
   \      0x2C6   0x....'....        ADR.W    R0,checkTask
   \      0x2CA   0x....'....        BL       OSTaskCreateExt
   \      0x2CE   0xF88D 0x0014      STRB     R0,[SP, #+20]
    221          
    222          #if (OS_TASK_NAME_SIZE >= 11)
    223          	OSTaskNameSet(TASK_DETECT_PRIO, (CPU_INT08U *)"Detect Task", &os_err);
   \      0x2D2   0xAA05             ADD      R2,SP,#+20
   \      0x2D4   0x....             ADR.N    R1,?_0
   \      0x2D6   0x2002             MOVS     R0,#+2
   \      0x2D8   0x....'....        BL       OSTaskNameSet
    224          	OSTaskNameSet(TASK_TEMPER_PRIO, (CPU_INT08U *)"Temperature Task", &os_err);
   \      0x2DC   0xF10D 0x0214      ADD.W    R2,SP,#+20
   \      0x2E0   0x....             ADR.N    R1,?_1
   \      0x2E2   0x2001             MOVS     R0,#+1
   \      0x2E4   0x....'....        BL       OSTaskNameSet
    225          	OSTaskNameSet(TASK_PASS_PRIO, (CPU_INT08U *)"Pass Task", &os_err);
   \      0x2E8   0xF10D 0x0214      ADD.W    R2,SP,#+20
   \      0x2EC   0x....             ADR.N    R1,?_2
   \      0x2EE   0x2007             MOVS     R0,#+7
   \      0x2F0   0x....'....        BL       OSTaskNameSet
    226          	OSTaskNameSet(TASK_DENY_PRIO, (CPU_INT08U *)"Deny Task", &os_err);
   \      0x2F4   0xF10D 0x0214      ADD.W    R2,SP,#+20
   \      0x2F8   0x....             ADR.N    R1,?_3
   \      0x2FA   0x2008             MOVS     R0,#+8
   \      0x2FC   0x....'....        BL       OSTaskNameSet
    227          	OSTaskNameSet(TASK_CHECK_PRIO, (CPU_INT08U *)"Check Task", &os_err);
   \      0x300   0xF10D 0x0214      ADD.W    R2,SP,#+20
   \      0x304   0x....             ADR.N    R1,?_4
   \      0x306   0x2006             MOVS     R0,#+6
   \      0x308   0x....'....        BL       OSTaskNameSet
    228          #endif
    229          
    230          	OSStart(); /* Start multitasking (i.e. give control to uC/OS-II).  */
   \      0x30C   0x....'....        BL       OSStart
    231          
    232          //	BSP_Init();
    233          //	OS_CPU_SysTickInit();
    234          //#if (OS_TASK_STAT_EN > 0)
    235          //	OSStatInit(); /* Determine CPU capacity.                              */
    236          //#endif
    237          //
    238          //#if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    239          //	 (APP_OS_PROBE_EN == DEF_ENABLED))
    240          //	App_InitProbe();
    241          //#endif
    242          
    243          	return (0);
   \      0x310   0x2000             MOVS     R0,#+0
   \      0x312   0xB01D             ADD      SP,SP,#+116
   \      0x314   0xBD30             POP      {R4,R5,PC}       ;; return
    244          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0xF88D 0x0014      STRB     R0,[SP, #+20]
   \                     ??Subroutine4_0: (+1)
   \        0x4   0x2280             MOVS     R2,#+128
   \        0x6   0x2003             MOVS     R0,#+3
   \        0x8   0x9004             STR      R0,[SP, #+16]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x9202             STR      R2,[SP, #+8]
   \        0x4   0x9301             STR      R3,[SP, #+4]
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0x9103             STR      R1,[SP, #+12]
   \        0xA   0x4770             BX       LR
    245          
    246          /*
    247           *********************************************************************************************************
    248           *                                          detectTask()
    249           *
    250           * Description : Human detecting task. Monitor the existence of people,
    251           *
    252           * Argument(s) : p
    253           *
    254           * Return(s)   : none.
    255           *
    256           * Caller(s)   : This is a task.
    257           *
    258           * Note(s)     : none.
    259           *********************************************************************************************************
    260           */
    261          
    262          // Task가 수행할 함수, 사람의 존재 유/무를 알려주는 Task

   \                                 In section .text, align 4, keep-with-next
    263          static void detectTask(void *p)
    264          {
   \                     detectTask: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    265          	CPU_INT08U err;
    266          
    267          	BSP_Init();
   \        0x2   0x....'....        BL       BSP_Init
    268          	OS_CPU_SysTickInit();
   \        0x6   0x....'....        BL       OS_CPU_SysTickInit
    269          #if (OS_TASK_STAT_EN > 0)
    270          	OSStatInit(); /* Determine CPU capacity.                              */
   \        0xA   0x....'....        BL       OSStatInit
    271          #endif
    272          
    273          #if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    274          	 (APP_OS_PROBE_EN == DEF_ENABLED))
    275          	App_InitProbe();
   \        0xE   0x....'....        BL       OSProbe_Init
   \       0x12   0x....'....        ADR.W    R0,App_ProbeCallback
   \       0x16   0x....             LDR.N    R4,??DataTable12_6
   \       0x18   0x....             LDR.N    R5,??DataTable12_1  ;; 0x40012400
   \       0x1A   0x....'....        BL       OSProbe_SetCallback
   \       0x1E   0x20FA             MOVS     R0,#+250
   \       0x20   0x....'....        BL       OSProbe_SetDelay
   \       0x24   0x....'....        BL       ProbeCom_Init
    276          #endif
    277          
    278          	while (DEF_TRUE)
    279          	{
    280          		ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   \                     ??detectTask_0: (+1)
   \       0x28   0x2101             MOVS     R1,#+1
   \       0x2A   0x4628             MOV      R0,R5
   \       0x2C   0x....'....        BL       ADC_SoftwareStartConvCmd
    281          
    282          		while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);
   \                     ??detectTask_1: (+1)
   \       0x30   0x2102             MOVS     R1,#+2
   \       0x32   0x4628             MOV      R0,R5
   \       0x34   0x....'....        BL       ADC_GetFlagStatus
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD0F9             BEQ.N    ??detectTask_1
    283          
    284          		ADC_value = ADC_GetConversionValue(ADC1);
    285          
    286          		if (ADC_value != RESET) // when human detected
   \       0x3C   0x4628             MOV      R0,R5
   \       0x3E   0x....'....        BL       ADC_GetConversionValue
   \       0x42   0xB930             CBNZ.N   R0,??detectTask_2
    287          		{
    288          			BSP_LED_On(4);
    289          			//BSP_LED_Off(0);
    290          			OSFlagPost(flagGroup, FLAG_DETECT, OS_FLAG_SET, &err);
    291          		}
    292          		else
    293          		{
    294          			BSP_LED_On(3);
   \       0x44   0x2003             MOVS     R0,#+3
   \       0x46   0x....'....        BL       BSP_LED_On
    295          			//BSP_LED_Off(3);
    296          			OSFlagPost(flagGroup, FLAG_DETECT_NOT, OS_FLAG_SET, &err);
   \       0x4A   0x466B             MOV      R3,SP
   \       0x4C   0x2201             MOVS     R2,#+1
   \       0x4E   0x2102             MOVS     R1,#+2
   \       0x50   0xE005             B.N      ??detectTask_3
    297          		}
   \                     ??detectTask_2: (+1)
   \       0x52   0x2004             MOVS     R0,#+4
   \       0x54   0x....'....        BL       BSP_LED_On
   \       0x58   0x466B             MOV      R3,SP
   \       0x5A   0x2201             MOVS     R2,#+1
   \       0x5C   0x2101             MOVS     R1,#+1
   \                     ??detectTask_3: (+1)
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x....'....        BL       OSFlagPost
    298          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
   \       0x64   0x....'....        BL       ?Subroutine2
    299          	}
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x68   0xE7DE             B.N      ??detectTask_0
    300          
    301          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x2364             MOVS     R3,#+100
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x....'....        B.W      OSTimeDlyHMSM
    302          
    303          /*
    304           *********************************************************************************************************
    305           *                                            temperTask()
    306           *
    307           * Description : Measure a person's temperature
    308           *
    309           * Argument(s) : p
    310           *
    311           * Return(s)   : none.
    312           *
    313           * Caller(s)   : This is a task.
    314           *
    315           * Note(s)     : none.
    316           *********************************************************************************************************
    317           */
    318          // 사람의 온도를 측정하여 통과할지 말지를 결정하는 Task

   \                                 In section .text, align 4, keep-with-next
    319          static void temperTask(void *p)
    320          {
   \                     temperTask: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    321          	INT8U err;
    322          	int temp;
    323          	int high = 39;
    324          	int low = 34;
   \        0x2   0x....             LDR.N    R4,??DataTable12_6
    325          	while (DEF_TRUE)
    326          	{
    327          		temp = readTemperature();
    328          		if (temp > high) // when temperature is HIGH
    329          		{
    330          			//OSQPost(temperQue, temp);
    331          			//BSP_LED_On(2);
    332          			//BSP_LED_Off(3);
    333          			OSFlagPost(flagGroup, FLAG_TEMPER_HIGH, OS_FLAG_SET, &err);
    334          		}
    335          		else if (temp < low)
    336          		{
    337          			//OSQPost(temperQue, temp);
    338          			//BSP_LED_On(2);
    339          			//BSP_LED_Off(3);
    340          			OSFlagPost(flagGroup, FLAG_TEMPER_LOW, OS_FLAG_SET, &err);
    341          		}
    342          		else
    343          		{
    344          			//BSP_LED_On(3);
    345          			//BSP_LED_Off(2);
    346          			OSFlagPost(flagGroup, FLAG_TEMPER_NORMAL, OS_FLAG_SET, &err);
   \                     ??temperTask_0: (+1)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x466B             MOV      R3,SP
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0x2104             MOVS     R1,#+4
   \        0xC   0x....'....        BL       OSFlagPost
    347          		}
    348          
    349          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
   \       0x10   0x....'....        BL       ?Subroutine2
    350          	}
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x14   0xE7F6             B.N      ??temperTask_0
    351          }
    352          
    353          static int readTemperature()
    354          {
    355          	// int high, low;
    356          	// int tmp = 0;
    357          
    358          	// while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY))
    359          	// 	;
    360          	// I2C_GenerateSTART(I2C1, ENABLE);
    361          	// while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))
    362          	// 	;
    363          	// I2C_Send7bitAddress(I2C1, addr, I2C_Direction_Transmitter);
    364          	// while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
    365          	// 	;
    366          	// I2C_SendData(I2C1, 0x0);
    367          	// while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
    368          	// 	;
    369          	// I2C_GenerateSTOP(I2C1, ENABLE);
    370          
    371          	// I2C_GenerateSTART(I2C1, ENABLE);
    372          	// while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))
    373          	// 	;
    374          	// I2C_Send7bitAddress(I2C1, addr, I2C_Direction_Receiver);
    375          	// while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
    376          	// 	;
    377          	// while ((I2C_GetLastEvent(I2C1) & I2C_FLAG_RXNE) != I2C_FLAG_RXNE)
    378          	// 	; /* Poll on RxNE */
    379          	// high = I2C_ReceiveData(I2C1);
    380          	// I2C_AcknowledgeConfig(I2C1, DISABLE);
    381          	// I2C_GenerateSTOP(I2C1, ENABLE);
    382          
    383          	// while ((I2C_GetLastEvent(I2C1) & I2C_FLAG_RXNE) != I2C_FLAG_RXNE)
    384          	// 	; /* Poll on RxNE */
    385          
    386          	// low = I2C_ReceiveData(I2C1);
    387          	// I2C_AcknowledgeConfig(I2C1, ENABLE);
    388          	// tmp = (uint16_t)(high << 8);
    389          
    390          	// tmp |= low;
    391          	// return tmp >> 7;
    392          	return 36;
    393          }
    394          
    395          /*
    396           *********************************************************************************************************
    397           *                                            passTask()
    398           *
    399           * Description : Those who are at normal body temperature are allowed to pass.
    400           *
    401           * Argument(s) : p
    402           *
    403           * Return(s)   : none.
    404           *
    405           * Caller(s)   : This is a task.
    406           *
    407           * Note(s)     : none.
    408           *********************************************************************************************************
    409           */
    410          // 정상체온인 사람은 통과를 허가하는 Task

   \                                 In section .text, align 4, keep-with-next
    411          static void passTask(void *p)
    412          {
   \                     passTask: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x....             LDR.N    R4,??DataTable12_7  ;; 0x40000034
   \        0x4   0x....             LDR.N    R5,??DataTable12_6
   \        0x6   0xE00D             B.N      ??CrossCallReturnLabel_9
    413          	int err;
    414          	while (DEF_TRUE)
    415          	{
    416          		OSFlagPend(flagGroup, FLAG_DETECT + FLAG_TEMPER_NORMAL, OS_FLAG_WAIT_SET_ALL + OS_FLAG_CONSUME, 0, (INT8U *)&err);
    417          		// dot-matrix
    418          		// TODO("dot-matrix pass");
    419          		// piezo
    420          		GPIO_SetBits(GPIOB, GPIO_Pin_8);
    421          		// door
    422          		for (int i = TIM2->CCR1; i < 2300; i += 2) // 1500 -> 2300
    423          		{
    424          			TIM2->CCR1 = i;
   \                     ??passTask_0: (+1)
   \        0x8   0x8020             STRH     R0,[R4, #+0]
    425          		}
   \        0xA   0x1C80             ADDS     R0,R0,#+2
   \                     ??passTask_1: (+1)
   \        0xC   0x4298             CMP      R0,R3
   \        0xE   0xDBFB             BLT.N    ??passTask_0
    426          
    427          		// stop setting
    428          		OSSemPend(sem, 0, (INT8U *)&err);
   \       0x10   0x6868             LDR      R0,[R5, #+4]
   \       0x12   0x....'....        BL       ?Subroutine6
    429          		count = 1;
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0x60A9             STR      R1,[R5, #+8]
    430          		OSSemPost(sem);
   \       0x1A   0x6868             LDR      R0,[R5, #+4]
   \       0x1C   0x....'....        BL       OSSemPost
    431          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
   \       0x20   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x24   0xA801             ADD      R0,SP,#+4
   \       0x26   0x9000             STR      R0,[SP, #+0]
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x6828             LDR      R0,[R5, #+0]
   \       0x2C   0x2282             MOVS     R2,#+130
   \       0x2E   0x2105             MOVS     R1,#+5
   \       0x30   0x....'....        BL       OSFlagPend
   \       0x34   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x38   0x8820             LDRH     R0,[R4, #+0]
   \       0x3A   0xF640 0x03FC      MOVW     R3,#+2300
   \       0x3E   0xE7E5             B.N      ??passTask_1
    432          	}
    433          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0xAA01             ADD      R2,SP,#+4
   \                     ??Subroutine6_0: (+1)
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x....'....        B.W      OSSemPend

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0xF44F 0x7180      MOV      R1,#+256
   \        0x4   0x....             LDR.N    R0,??DataTable12  ;; 0x40010c00
   \        0x6   0x....'....        B.W      GPIO_SetBits
    434          
    435          /*
    436           *********************************************************************************************************
    437           *                                            denyTask()
    438           *
    439           * Description : People with abnormal body temperature are not allowed to pass through.
    440           *
    441           * Argument(s) : p
    442           *
    443           * Return(s)   : none.
    444           *
    445           * Caller(s)   : This is a task.
    446           *
    447           * Note(s)     : none.
    448           *********************************************************************************************************
    449           */
    450          // 비정상체온인 사람은 통과를 불허하는 Task

   \                                 In section .text, align 4, keep-with-next
    451          static void denyTask(void *p)
    452          {
   \                     denyTask: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    453          	int err;
    454          	int temp = 0;
   \        0x2   0x....             LDR.N    R4,??DataTable12_6
    455          	while (DEF_TRUE)
    456          	{
    457          		int flags =
    458          			OSFlagPend(flagGroup,
    459          					   FLAG_TEMPER_HIGH + FLAG_TEMPER_LOW + FLAG_DETECT_NOT,
    460          					   OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
    461          					   0,
    462          					   (INT8U *)&err);
    463          		if ((flags & FLAG_TEMPER_HIGH) == FLAG_TEMPER_HIGH)
   \                     ??denyTask_0: (+1)
   \        0x4   0xA801             ADD      R0,SP,#+4
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x2283             MOVS     R2,#+131
   \        0xE   0x211A             MOVS     R1,#+26
   \       0x10   0x....'....        BL       OSFlagPend
   \       0x14   0x0700             LSLS     R0,R0,#+28
   \       0x16   0xD501             BPL.N    ??CrossCallReturnLabel_19
    464          		{
    465          			// dot-matrix
    466          			// TODO("dot-matrix deny");
    467          			// piezo
    468          			GPIO_SetBits(GPIOB, GPIO_Pin_8);
   \       0x18   0x....'....        BL       ?Subroutine5
    469          		}
    470          		else if ((flags & FLAG_TEMPER_LOW) == FLAG_TEMPER_LOW)
    471          		{
    472          			// dot-matrix
    473          			// TODO("dot-matrix deny");
    474          		}
    475          		OSSemPend(sem, 0, (INT8U *)&err);
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x1C   0x6860             LDR      R0,[R4, #+4]
   \       0x1E   0x....'....        BL       ?Subroutine6
    476          		count = 1;
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x60A0             STR      R0,[R4, #+8]
    477          		OSSemPost(sem);
   \       0x26   0x6860             LDR      R0,[R4, #+4]
   \       0x28   0x....'....        BL       OSSemPost
    478          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
   \       0x2C   0x....'....        BL       ?Subroutine2
    479          	}
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x30   0xE7E8             B.N      ??denyTask_0
    480          }
    481          
    482          /*
    483           *********************************************************************************************************
    484           *                                            checkTask()
    485           *
    486           * Description : Check dot-matrix, piezo, motor.
    487           *
    488           * Argument(s) : p
    489           *
    490           * Return(s)   : none.
    491           *
    492           * Caller(s)   : This is a task.
    493           *
    494           * Note(s)     : none.
    495           *********************************************************************************************************
    496           */
    497          // dot-matrix, piezo, motor를 1초 후 정지하도록 하는 Task

   \                                 In section .text, align 4, keep-with-next
    498          static void checkTask(void *p)
    499          {
   \                     checkTask: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
    500          	CPU_INT08U err;
    501          	int isStop = 0;
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x....             LDR.N    R5,??DataTable12_7  ;; 0x40000034
   \        0x6   0x....             LDR.N    R6,??DataTable12_6
   \        0x8   0xE006             B.N      ??CrossCallReturnLabel_7
    502          	while (DEF_TRUE)
    503          	{
    504          		if (count != 0)
    505          		{
    506          			OSSemPend(sem, 0, &err);
    507          			if (count > TIME_COUNT)
    508          			{
    509          				isStop = 1; // Use flag / Don't do a lot of work in sem
    510          				count = 0;	// init time counter
    511          			}
    512          			count++;
    513          			OSSemPost(sem);
    514          
    515          			// STOP: Do out of sem
    516          			if (isStop == 1)
    517          			{
   \                     ??checkTask_0: (+1)
   \        0xA   0x8028             STRH     R0,[R5, #+0]
   \        0xC   0x1E80             SUBS     R0,R0,#+2
   \                     ??checkTask_1: (+1)
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xDAFB             BGE.N    ??checkTask_0
    518          				stopAll();
    519          				isStop = 0;
   \       0x12   0x2400             MOVS     R4,#+0
    520          			}
    521          		}
    522          
    523          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
   \                     ??checkTask_2: (+1)
   \       0x14   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x18   0x68B0             LDR      R0,[R6, #+8]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD0FA             BEQ.N    ??checkTask_2
   \       0x1E   0x6870             LDR      R0,[R6, #+4]
   \       0x20   0x466A             MOV      R2,SP
   \       0x22   0x....'....        BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x26   0x68B0             LDR      R0,[R6, #+8]
   \       0x28   0x280A             CMP      R0,#+10
   \       0x2A   0xBFA4             ITT      GE
   \       0x2C   0x2401             MOVGE    R4,#+1
   \       0x2E   0x2000             MOVGE    R0,#+0
   \       0x30   0x1C40             ADDS     R0,R0,#+1
   \       0x32   0x60B0             STR      R0,[R6, #+8]
   \       0x34   0x6870             LDR      R0,[R6, #+4]
   \       0x36   0x....'....        BL       OSSemPost
   \       0x3A   0x2C00             CMP      R4,#+0
   \       0x3C   0xD0EA             BEQ.N    ??checkTask_2
   \       0x3E   0xF44F 0x7180      MOV      R1,#+256
   \       0x42   0x....             LDR.N    R0,??DataTable12  ;; 0x40010c00
   \       0x44   0x....'....        BL       GPIO_ResetBits
   \       0x48   0x8828             LDRH     R0,[R5, #+0]
   \       0x4A   0xF240 0x51DD      MOVW     R1,#+1501
   \       0x4E   0xE7DE             B.N      ??checkTask_1
    524          	}
    525          }
    526          
    527          // Stop all
    528          static void stopAll()
    529          {
    530          	// dot-matrix
    531          
    532          	// piezo
    533          	GPIO_ResetBits(GPIOB, GPIO_Pin_8);
    534          	// motor
    535          	for (int i = TIM2->CCR1; i > 1500; i -= 2) // 2300 -> 1500
    536          	{
    537          		TIM2->CCR1 = i;
    538          	}
    539          }
    540          /*
    541           *********************************************************************************************************
    542           *                                          App_DispScr_SignOn()
    543           *
    544           * Description : Display uC/OS-II system information on the LCD.
    545           *
    546           * Argument(s) : none.
    547           *
    548           * Return(s)   : none.
    549           *
    550           * Caller(s)   : TaskUserIF().
    551           *
    552           * Note(s)     : none.
    553           *********************************************************************************************************
    554           */
    555          
    556          static void App_DispScr_SignOn(void)
    557          {
    558          }
    559          
    560          /*
    561           *********************************************************************************************************
    562           *                                          App_DispScr_SignOn()
    563           *
    564           * Description : Display uC/OS-II system information on the LCD.
    565           *
    566           * Argument(s) : none.
    567           *
    568           * Return(s)   : none.
    569           *
    570           * Caller(s)   : TaskUserIF().
    571           *
    572           * Note(s)     : none.
    573           *********************************************************************************************************
    574           */
    575          
    576          static void App_DispScr_TaskNames(void)
    577          {
    578          }
    579          
    580          /*
    581           *********************************************************************************************************
    582           *                                             App_InitProbe()
    583           *
    584           * Description : Initialize uC/Probe target code.
    585           *
    586           * Argument(s) : none.
    587           *
    588           * Return(s)   : none.
    589           *
    590           * Caller(s)   : App_TaskStart().
    591           *
    592           * Note(s)     : none.
    593           *********************************************************************************************************
    594           */
    595          
    596          #if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    597          	 (APP_OS_PROBE_EN == DEF_ENABLED))
    598          static void App_InitProbe(void)
    599          {
    600          #if (APP_OS_PROBE_EN == DEF_ENABLED)
    601          	(void)App_ProbeCounts;
    602          	(void)App_ProbeB1;
    603          
    604          #if ((APP_PROBE_COM_EN == DEF_ENABLED) && \
    605          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
    606          	(void)App_ProbeComRxPktSpd;
    607          	(void)App_ProbeComTxPktSpd;
    608          	(void)App_ProbeComTxSymSpd;
    609          	(void)App_ProbeComTxSymByteSpd;
    610          #endif
    611          
    612          	OSProbe_Init();
    613          	OSProbe_SetCallback(App_ProbeCallback);
    614          	OSProbe_SetDelay(250);
    615          #endif
    616          
    617          #if (APP_PROBE_COM_EN == DEF_ENABLED)
    618          	ProbeCom_Init(); /* Initialize the uC/Probe communications module.       */
    619          #endif
    620          }
    621          #endif
    622          
    623          /*
    624           *********************************************************************************************************
    625           *                                         AppProbeCallback()
    626           *
    627           * Description : uC/Probe OS plugin callback.
    628           *
    629           * Argument(s) : none.
    630           *
    631           * Return(s)   : none.
    632           *
    633           * Caller(s)   : uC/Probe OS plugin task.
    634           *
    635           * Note(s)     : none.
    636           *********************************************************************************************************
    637           */
    638          
    639          #if (APP_OS_PROBE_EN == DEF_ENABLED)

   \                                 In section .text, align 4, keep-with-next
    640          static void App_ProbeCallback(void)
    641          {
   \                     App_ProbeCallback: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    642          #if ((APP_PROBE_COM_EN == DEF_ENABLED) && \
    643          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
    644          	CPU_INT32U ctr_curr;
    645          	CPU_INT32U rxpkt_curr;
    646          	CPU_INT32U txpkt_curr;
    647          	CPU_INT32U sym_curr;
    648          	CPU_INT32U symbyte_curr;
    649          #endif
    650          
    651          	App_ProbeCounts++;
   \        0x2   0x....             LDR.N    R4,??DataTable12_8
   \        0x4   0x6961             LDR      R1,[R4, #+20]
   \        0x6   0x1C49             ADDS     R1,R1,#+1
   \        0x8   0x6161             STR      R1,[R4, #+20]
    652          
    653          	App_ProbeB1 = BSP_PB_GetStatus(1);
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x....'....        BL       BSP_PB_GetStatus
    654          
    655          #if ((APP_PROBE_COM_EN == DEF_ENABLED) && \
    656          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
    657          	ctr_curr = OSTime;
   \       0x10   0x....             LDR.N    R1,??DataTable12_9
   \       0x12   0x6808             LDR      R0,[R1, #+0]
    658          	rxpkt_curr = ProbeCom_RxPktCtr;
    659          	txpkt_curr = ProbeCom_TxPktCtr;
    660          	sym_curr = ProbeCom_TxSymCtr;
    661          	symbyte_curr = ProbeCom_TxSymByteCtr;
    662          
    663          	if ((ctr_curr - App_ProbeComCtrLast) >= OS_TICKS_PER_SEC)
   \       0x14   0x6922             LDR      R2,[R4, #+16]
   \       0x16   0x1A82             SUBS     R2,R0,R2
   \       0x18   0xF5B2 0x7F7A      CMP      R2,#+1000
   \       0x1C   0xD30C             BCC.N    ??App_ProbeCallback_0
    664          	{
    665          		App_ProbeComRxPktSpd = ((CPU_FP32)(rxpkt_curr - App_ProbeComRxPktLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    666          		App_ProbeComTxPktSpd = ((CPU_FP32)(txpkt_curr - App_ProbeComTxPktLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    667          		App_ProbeComTxSymSpd = ((CPU_FP32)(sym_curr - App_ProbeComTxSymLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    668          		App_ProbeComTxSymByteSpd = ((CPU_FP32)(symbyte_curr - App_ProbeComTxSymByteLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    669          
    670          		App_ProbeComCtrLast = ctr_curr;
   \       0x1E   0x6120             STR      R0,[R4, #+16]
    671          		App_ProbeComRxPktLast = rxpkt_curr;
    672          		App_ProbeComTxPktLast = txpkt_curr;
   \       0x20   0x....             LDR.N    R2,??DataTable12_10
   \       0x22   0x....             LDR.N    R0,??DataTable12_11
   \       0x24   0x6801             LDR      R1,[R0, #+0]
    673          		App_ProbeComTxSymLast = sym_curr;
   \       0x26   0x....             LDR.N    R0,??DataTable12_12
   \       0x28   0x6021             STR      R1,[R4, #+0]
   \       0x2A   0x6813             LDR      R3,[R2, #+0]
    674          		App_ProbeComTxSymByteLast = symbyte_curr;
   \       0x2C   0x....             LDR.N    R2,??DataTable12_13
   \       0x2E   0x6063             STR      R3,[R4, #+4]
   \       0x30   0x6801             LDR      R1,[R0, #+0]
   \       0x32   0x60A1             STR      R1,[R4, #+8]
   \       0x34   0x6810             LDR      R0,[R2, #+0]
   \       0x36   0x60E0             STR      R0,[R4, #+12]
    675          	}
    676          #endif
    677          }
   \                     ??App_ProbeCallback_0: (+1)
   \       0x38   0xBD10             POP      {R4,PC}          ;; return
    678          #endif
    679          
    680          /*
    681           *********************************************************************************************************
    682           *                                      App_FormatDec()
    683           *
    684           * Description : Convert a decimal value to ASCII (without leading zeros).
    685           *
    686           * Argument(s) : pstr            Pointer to the destination ASCII string.
    687           *
    688           *               value           Value to convert (assumes an unsigned value).
    689           *
    690           *               digits          The desired number of digits.
    691           *
    692           * Return(s)   : none.
    693           *
    694           * Caller(s)   : various.
    695           *
    696           * Note(s)     : none.
    697           *********************************************************************************************************
    698           */
    699          
    700          /*
    701           *********************************************************************************************************
    702           *********************************************************************************************************
    703           *                                          uC/OS-II APP HOOKS
    704           *********************************************************************************************************
    705           *********************************************************************************************************
    706           */
    707          
    708          #if (OS_APP_HOOKS_EN > 0)
    709          /*
    710           *********************************************************************************************************
    711           *                                      TASK CREATION HOOK (APPLICATION)
    712           *
    713           * Description : This function is cal when a task is created.
    714           *
    715           * Argument(s) : ptcb   is a pointer to the task control block of the task being created.
    716           *
    717           * Note(s)     : (1) Interrupts are disabled during this call.
    718           *********************************************************************************************************
    719           */
    720          

   \                                 In section .text, align 2, keep-with-next
    721          void App_TaskCreateHook(OS_TCB *ptcb)
    722          {
    723          #if ((APP_OS_PROBE_EN == DEF_ENABLED) && \
    724          	 (OS_PROBE_HOOKS_EN == DEF_ENABLED))
    725          	OSProbe_TaskCreateHook(ptcb);
   \                     App_TaskCreateHook: (+1)
   \        0x0   0x....'....        B.W      OSProbe_TaskCreateHook
    726          #endif
    727          }
    728          
    729          /*
    730           *********************************************************************************************************
    731           *                                    TASK DELETION HOOK (APPLICATION)
    732           *
    733           * Description : This function is called when a task is deleted.
    734           *
    735           * Argument(s) : ptcb   is a pointer to the task control block of the task being deleted.
    736           *
    737           * Note(s)     : (1) Interrupts are disabled during this call.
    738           *********************************************************************************************************
    739           */
    740          

   \                                 In section .text, align 2, keep-with-next
    741          void App_TaskDelHook(OS_TCB *ptcb)
    742          {
    743          	(void)ptcb;
    744          }
   \                     App_TaskDelHook: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    745          
    746          /*
    747           *********************************************************************************************************
    748           *                                      IDLE TASK HOOK (APPLICATION)
    749           *
    750           * Description : This function is called by OSTaskIdleHook(), which is called by the idle task.  This hook
    751           *               has been added to allow you to do such things as STOP the CPU to conserve power.
    752           *
    753           * Argument(s) : none.
    754           *
    755           * Note(s)     : (1) Interrupts are enabled during this call.
    756           *********************************************************************************************************
    757           */
    758          
    759          #if OS_VERSION >= 251

   \                                 In section .text, align 2, keep-with-next
    760          void App_TaskIdleHook(void)
    761          {
    762          }
   \                     App_TaskIdleHook: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    763          #endif
    764          
    765          /*
    766           *********************************************************************************************************
    767           *                                        STATISTIC TASK HOOK (APPLICATION)
    768           *
    769           * Description : This function is called by OSTaskStatHook(), which is called every second by uC/OS-II's
    770           *               statistics task.  This allows your application to add functionality to the statistics task.
    771           *
    772           * Argument(s) : none.
    773           *********************************************************************************************************
    774           */
    775          

   \                                 In section .text, align 2, keep-with-next
    776          void App_TaskStatHook(void)
    777          {
    778          }
   \                     App_TaskStatHook: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    779          
    780          /*
    781           *********************************************************************************************************
    782           *                                        TASK SWITCH HOOK (APPLICATION)
    783           *
    784           * Description : This function is called when a task switch is performed.  This allows you to perform other
    785           *               operations during a context switch.
    786           *
    787           * Argument(s) : none.
    788           *
    789           * Note(s)     : (1) Interrupts are disabled during this call.
    790           *
    791           *               (2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
    792           *                   will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
    793           *                  task being switched out (i.e. the preempted task).
    794           *********************************************************************************************************
    795           */
    796          
    797          #if OS_TASK_SW_HOOK_EN > 0

   \                                 In section .text, align 2, keep-with-next
    798          void App_TaskSwHook(void)
    799          {
    800          #if ((APP_OS_PROBE_EN == DEF_ENABLED) && \
    801          	 (OS_PROBE_HOOKS_EN == DEF_ENABLED))
    802          	OSProbe_TaskSwHook();
   \                     App_TaskSwHook: (+1)
   \        0x0   0x....'....        B.W      OSProbe_TaskSwHook
    803          #endif
    804          }
    805          #endif
    806          
    807          /*
    808           *********************************************************************************************************
    809           *                                     OS_TCBInit() HOOK (APPLICATION)
    810           *
    811           * Description : This function is called by OSTCBInitHook(), which is called by OS_TCBInit() after setting
    812           *               up most of the TCB.
    813           *
    814           * Argument(s) : ptcb    is a pointer to the TCB of the task being created.
    815           *
    816           * Note(s)     : (1) Interrupts may or may not be ENABLED during this call.
    817           *********************************************************************************************************
    818           */
    819          
    820          #if OS_VERSION >= 204

   \                                 In section .text, align 2, keep-with-next
    821          void App_TCBInitHook(OS_TCB *ptcb)
    822          {
    823          	(void)ptcb;
    824          }
   \                     App_TCBInitHook: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    825          #endif
    826          
    827          /*
    828           *********************************************************************************************************
    829           *                                        TICK HOOK (APPLICATION)
    830           *
    831           * Description : This function is called every tick.
    832           *
    833           * Argument(s) : none.
    834           *
    835           * Note(s)     : (1) Interrupts may or may not be ENABLED during this call.
    836           *********************************************************************************************************
    837           */
    838          
    839          #if OS_TIME_TICK_HOOK_EN > 0

   \                                 In section .text, align 2, keep-with-next
    840          void App_TimeTickHook(void)
    841          {
    842          #if ((APP_OS_PROBE_EN == DEF_ENABLED) && \
    843          	 (OS_PROBE_HOOKS_EN == DEF_ENABLED))
    844          	OSProbe_TickHook();
   \                     App_TimeTickHook: (+1)
   \        0x0   0x....'....        B.W      OSProbe_TickHook
    845          #endif
    846          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x....'....        B.W      GPIO_Init

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x2118             MOVS     R1,#+24
   \                     ??Subroutine0_0: (+1)
   \        0x2   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \        0x6   0xF88D 0x1003      STRB     R1,[SP, #+3]
   \        0xA   0x2203             MOVS     R2,#+3
   \        0xC   0xF88D 0x2002      STRB     R2,[SP, #+2]
   \       0x10   0x4669             MOV      R1,SP
   \       0x12   0x4628             MOV      R0,R5
   \       0x14   0x....'....        B.W      GPIO_Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x4001'0C00        DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x4001'2400        DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x0001'86A0        DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x4000'5400        DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0x4000'0800        DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0x4000'3800        DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \        0x0   0x....'....        DC32     flagGroup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \        0x0   0x4000'0034        DC32     0x40000034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \        0x0   0x....'....        DC32     App_ProbeComRxPktLast

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \        0x0   0x....'....        DC32     OSTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \        0x0   0x....'....        DC32     ProbeCom_TxPktCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \        0x0   0x....'....        DC32     ProbeCom_RxPktCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \        0x0   0x....'....        DC32     ProbeCom_TxSymCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \        0x0   0x....'....        DC32     ProbeCom_TxSymByteCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x44 0x65          DC8 "Detect Task"

   \              0x74 0x65    

   \              0x63 0x74    

   \              0x20 0x54    

   \              0x61 0x73    

   \              0x6B 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x54 0x65          DC8 "Temperature Task"

   \              0x6D 0x70    

   \              0x65 0x72    

   \              0x61 0x74    

   \              0x75 0x72    

   \              0x65 0x20    

   \              0x54 0x61    

   \              0x73 0x6B    

   \              0x00
   \       0x11                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x50 0x61          DC8 "Pass Task"

   \              0x73 0x73    

   \              0x20 0x54    

   \              0x61 0x73    

   \              0x6B 0x00
   \        0xA                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x44 0x65          DC8 "Deny Task"

   \              0x6E 0x79    

   \              0x20 0x54    

   \              0x61 0x73    

   \              0x6B 0x00
   \        0xA                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \        0x0   0x43 0x68          DC8 "Check Task"

   \              0x65 0x63    

   \              0x6B 0x20    

   \              0x54 0x61    

   \              0x73 0x6B    

   \              0x00
   \        0xB                      DS8 1
    847          #endif
    848          #endif
    849          
    850          static void initAll()
    851          {
    852          	ADC_InitTypeDef adc_init;
    853          	GPIO_InitTypeDef gpio_init;
    854          	I2C_InitTypeDef i2c_init;
    855          	TIM_TimeBaseInitTypeDef tim_timebase_init;
    856          	TIM_OCInitTypeDef tim_piezo_init;
    857          	TIM_OCInitTypeDef tim_motor_init;
    858          	SPI_InitTypeDef spi_init;
    859          
    860          	// CLOCK
    861          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
    862          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
    863          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
    864          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
    865          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    866          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    867          
    868          	// PIN
    869          	// ADC
    870          	gpio_init.GPIO_Pin = GPIO_Pin_0;
    871          	gpio_init.GPIO_Mode = GPIO_Mode_AIN;
    872          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    873          	GPIO_Init(GPIOB, &gpio_init);
    874          	// I2C
    875          	gpio_init.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
    876          	gpio_init.GPIO_Mode = GPIO_Mode_AF_OD;
    877          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    878          	GPIO_Init(GPIOB, &gpio_init);
    879          	// TIM (PWM)
    880          	// Piezo
    881          	gpio_init.GPIO_Pin = GPIO_Pin_8;
    882          	gpio_init.GPIO_Mode = GPIO_Mode_AF_PP;
    883          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    884          	GPIO_Init(GPIOB, &gpio_init);
    885          	// Motor
    886          	gpio_init.GPIO_Pin = GPIO_Pin_9;
    887          	gpio_init.GPIO_Mode = GPIO_Mode_AF_PP;
    888          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    889          	GPIO_Init(GPIOB, &gpio_init);
    890          	// SPI
    891          	GPIO_Init(GPIOB, &gpio_init);
    892          	gpio_init.GPIO_Pin = GPIO_Pin_12;
    893          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    894          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
    895          	GPIO_Init(GPIOB, &gpio_init);
    896          	gpio_init.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
    897          	gpio_init.GPIO_Mode = GPIO_Mode_AF_PP;
    898          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    899          	GPIO_Init(GPIOB, &gpio_init);
    900          	GPIO_SetBits(GPIOB, GPIO_Pin_12); // check
    901          
    902          	// CONFIG
    903          	// ADC
    904          	adc_init.ADC_Mode = ADC_Mode_Independent;
    905          	adc_init.ADC_ScanConvMode = ENABLE;
    906          	adc_init.ADC_ContinuousConvMode = ENABLE;
    907          	adc_init.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
    908          	adc_init.ADC_DataAlign = ADC_DataAlign_Right;
    909          	adc_init.ADC_NbrOfChannel = 1;
    910          	ADC_Init(ADC1, &adc_init);
    911          	ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 1, ADC_SampleTime_41Cycles5);
    912          	//ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);
    913          	ADC_Cmd(ADC1, ENABLE);
    914          
    915          	ADC_ResetCalibration(ADC1);
    916          	while (ADC_GetResetCalibrationStatus(ADC1) != RESET)
    917          		;
    918          	ADC_StartCalibration(ADC1);
    919          	while (ADC_GetCalibrationStatus(ADC1) != RESET)
    920          		;
    921          	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
    922          	// I2C
    923          	i2c_init.I2C_Mode = I2C_Mode_I2C;
    924          	i2c_init.I2C_DutyCycle = I2C_DutyCycle_2;
    925          	i2c_init.I2C_OwnAddress1 = 0;
    926          	i2c_init.I2C_Ack = I2C_Ack_Enable;
    927          	i2c_init.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    928          	i2c_init.I2C_ClockSpeed = 100000;
    929          	I2C_Init(((I2C_TypeDef *)I2C1_BASE), &i2c_init);
    930          	I2C_Cmd(((I2C_TypeDef *)I2C1_BASE), ENABLE);
    931          	// TIM (PWM)
    932          	tim_timebase_init.TIM_Prescaler = (72000000 / 1000000) - 1; // set to 1MHz Counter Clock
    933          	tim_timebase_init.TIM_Period = 20000 - 1;					// set to 50Hz pulse with 1MHz Counter Clock
    934          	tim_timebase_init.TIM_ClockDivision = 0;
    935          	tim_timebase_init.TIM_CounterMode = TIM_CounterMode_Down;
    936          	tim_timebase_init.TIM_RepetitionCounter;
    937          	TIM_TimeBaseInit(TIM4, &tim_timebase_init);
    938          	/* PIEZO: PWM1 Mode configuration: Channel3 */
    939          	tim_piezo_init.TIM_OCMode = TIM_OCMode_PWM1;
    940          	tim_piezo_init.TIM_OutputState = TIM_OutputState_Enable;
    941          	tim_piezo_init.TIM_Pulse = 500;
    942          	tim_piezo_init.TIM_OCPolarity = TIM_OCPolarity_High;
    943          	TIM_OC3Init(TIM4, &tim_piezo_init);
    944          	//TIM_OC3PreloadConfig(TIM4, TIM_OCPreload_Disable);
    945          	TIM_Cmd(TIM4, ENABLE);
    946          	/* MOTOR: PWM1 Mode configuration: Channel4 */
    947          	tim_motor_init.TIM_OCMode = TIM_OCMode_PWM1;
    948          	tim_motor_init.TIM_OutputState = TIM_OutputState_Enable;
    949          	tim_motor_init.TIM_Pulse = 1500; // 50 % duty cylce value
    950          	tim_motor_init.TIM_OCPolarity = TIM_OCPolarity_High;
    951          
    952          	//TIM_PWMIConfig(TIM4, &tim_motor_init);
    953          	TIM_OC4Init(TIM4, &tim_motor_init);
    954          	TIM_OC4PreloadConfig(TIM4, TIM_OCPreload_Disable);
    955          	TIM_ARRPreloadConfig(TIM4, ENABLE);
    956          	TIM_Cmd(TIM4, ENABLE);
    957          	// SPI
    958          	spi_init.SPI_Direction = SPI_Direction_1Line_Tx;
    959          	spi_init.SPI_Mode = SPI_Mode_Master;
    960          	spi_init.SPI_DataSize = SPI_DataSize_16b;
    961          	spi_init.SPI_CPOL = SPI_CPOL_Low;
    962          	spi_init.SPI_CPHA = SPI_CPHA_1Edge;
    963          	spi_init.SPI_NSS = SPI_NSS_Soft;
    964          	spi_init.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
    965          	spi_init.SPI_FirstBit = SPI_FirstBit_MSB;
    966          	spi_init.SPI_CRCPolynomial;
    967          	SPI_Init(SPI2, &spi_init);
    968          	SPI_Cmd(SPI2, ENABLE);
    969          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   App_ProbeCallback
         8   -> BSP_PB_GetStatus
       0   App_TCBInitHook
       0   App_TaskCreateHook
         0   -> OSProbe_TaskCreateHook
       0   App_TaskDelHook
       0   App_TaskIdleHook
       0   App_TaskStatHook
       0   App_TaskSwHook
         0   -> OSProbe_TaskSwHook
       0   App_TimeTickHook
         0   -> OSProbe_TickHook
      24   checkTask
        24   -> GPIO_ResetBits
        24   -> OSSemPend
        24   -> OSSemPost
        24   -> OSTimeDlyHMSM
      16   denyTask
        16   -> GPIO_SetBits
        16   -> OSFlagPend
        16   -> OSSemPend
        16   -> OSSemPost
        16   -> OSTimeDlyHMSM
      16   detectTask
        16   -> ADC_GetConversionValue
        16   -> ADC_GetFlagStatus
        16   -> ADC_SoftwareStartConvCmd
        16   -> BSP_Init
        16   -> BSP_LED_On
        16   -> OSFlagPost
        16   -> OSProbe_Init
        16   -> OSProbe_SetCallback
        16   -> OSProbe_SetDelay
        16   -> OSStatInit
        16   -> OSTimeDlyHMSM
        16   -> OS_CPU_SysTickInit
        16   -> ProbeCom_Init
     128   main
       128   -> ADC_Cmd
       128   -> ADC_GetCalibrationStatus
       128   -> ADC_GetResetCalibrationStatus
       128   -> ADC_Init
       128   -> ADC_RegularChannelConfig
       128   -> ADC_ResetCalibration
       128   -> ADC_SoftwareStartConvCmd
       128   -> ADC_StartCalibration
       128   -> BSP_IntDisAll
       128   -> GPIO_Init
       128   -> GPIO_SetBits
       128   -> I2C_Cmd
       128   -> I2C_Init
       128   -> OSFlagCreate
       128   -> OSInit
       128   -> OSSemCreate
       128   -> OSStart
       128   -> OSTaskCreateExt
       128   -> OSTaskNameSet
       128   -> RCC_APB1PeriphClockCmd
       128   -> RCC_APB2PeriphClockCmd
       128   -> SPI_Cmd
       128   -> SPI_Init
       128   -> TIM_ARRPreloadConfig
       128   -> TIM_Cmd
       128   -> TIM_OC3Init
       128   -> TIM_OC4Init
       128   -> TIM_OC4PreloadConfig
       128   -> TIM_TimeBaseInit
      24   passTask
        24   -> GPIO_SetBits
        24   -> OSFlagPend
        24   -> OSSemPend
        24   -> OSSemPost
        24   -> OSTimeDlyHMSM
      16   temperTask
        16   -> OSFlagPost
        16   -> OSTimeDlyHMSM


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
      24  ?Subroutine0
      12  ?Subroutine1
      12  ?Subroutine2
       8  ?Subroutine3
      12  ?Subroutine4
      10  ?Subroutine5
       8  ?Subroutine6
      12  ?_0
      20  ?_1
      12  ?_2
      12  ?_3
      12  ?_4
       4  ADC_value
       1  App_ProbeB1
      58  App_ProbeCallback
      24  App_ProbeComRxPktLast
          App_ProbeComTxPktLast
          App_ProbeComTxSymLast
          App_ProbeComTxSymByteLast
          App_ProbeComCtrLast
          App_ProbeCounts
       4  App_ProbeComRxPktSpd
       4  App_ProbeComTxPktSpd
       4  App_ProbeComTxSymByteSpd
       4  App_ProbeComTxSymSpd
       2  App_TCBInitHook
       4  App_TaskCreateHook
       2  App_TaskDelHook
       2  App_TaskIdleHook
       2  App_TaskStatHook
       4  App_TaskSwHook
       4  App_TimeTickHook
      80  checkTask
      50  denyTask
     106  detectTask
   2'572  flagGroup
          sem
          count
          detectTaskStack
          temperatureTaskStack
          passTaskStack
          denyTaskStack
          checkTaskStack
     790  main
      64  passTask
      22  temperTask

 
 2'617 bytes in section .bss
 1'400 bytes in section .text
 
 1'400 bytes of CODE memory
 2'617 bytes of DATA memory

Errors: none
Warnings: 8
