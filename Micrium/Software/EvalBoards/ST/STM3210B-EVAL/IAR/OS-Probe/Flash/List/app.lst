###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         17/Dec/2020  00:45:26
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\app.c
#    Command line                 =
#        -f C:\Users\fabi8\AppData\Local\Temp\EW427.tmp
#        (D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\app.c
#        -lCN
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List
#        -o
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "D:\Develop\IAR Systems\arm\inc\c\DLib_Config_Normal.h" -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\ports\arm-cortex-m3\generic\iar\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\source\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-lib\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\ARM-Cortex-M3\IAR\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\cpu\st\stm32\inc\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\BSP\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II\\
#        -Ohz --use_c++_inline)
#    Locale                       =  C
#    List file                    =
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List\app.lst
#    Object file                  =
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj\app.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __size_limit               =  32768|ARM.EW.LINKER
#
###############################################################################

D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\app.c
      1          /*
      2           *********************************************************************************************************
      3           *                                              TERM PROJECT
      4           *                          (C) Copyright 2020; Lee Seung Yun; Shim Jae Yeong
      5           *               Some codes are referenced below.
      6           * 
      7           *                                              EXAMPLE CODE
      8           *
      9           *                          (c) Copyright 2003-2006; Micrium, Inc.; Weston, FL
     10           *
     11           *               All rights reserved.  Protected by international copyright laws.
     12           *               Knowledge of the source code may NOT be used to develop a similar product.
     13           *               Please help us continue to provide the Embedded community with the finest
     14           *               software available.  Your honesty is greatly appreciated.
     15           *********************************************************************************************************
     16           */
     17          
     18          /*
     19           *********************************************************************************************************
     20           *
     21           *                             High Temperature Entrance Checking Technique
     22           *
     23           *                                     ST Microelectronics STM32
     24           *                                              with the
     25           *                                   STM3210B-EVAL Evaluation Board
     26           *
     27           * Filename      : app.c
     28           * Version       : V1.0
     29           * Programmer(s) : Lee Seung Yun, Shim Jae Yeong
     30           *********************************************************************************************************
     31           */
     32          
     33          /*
     34           *********************************************************************************************************
     35           *                                             INCLUDE FILES
     36           *********************************************************************************************************
     37           */
     38          
     39          #include <includes.h>
     40          #include <stm32f10x_gpio.h>
     41          #include <stm32f10x_rcc.h>
     42          #include <stm32f10x_i2c.h>
     43          #include <stm32f10x_adc.h>
     44          #include <stm32f10x_spi.h>
     45          #include <stm32f10x_tim.h>
     46          
     47          /*
     48           *********************************************************************************************************
     49           *                                            LOCAL DEFINES
     50           *********************************************************************************************************
     51           */
     52          
     53          /*
     54           *********************************************************************************************************
     55           *                                       LOCAL GLOBAL VARIABLES
     56           *********************************************************************************************************
     57           */
     58          
     59          // Task Stack (size: 128)
     60          static OS_STK detectTaskStack[TASK_STK_SIZE];
     61          static OS_STK temperatureTaskStack[TASK_STK_SIZE];
     62          static OS_STK passTaskStack[TASK_STK_SIZE];
     63          static OS_STK denyTaskStack[TASK_STK_SIZE];
     64          static OS_STK checkTaskStack[TASK_STK_SIZE];
     65          
     66          // Message Que
     67          static OS_EVENT *temperQue;
     68          static void *msg[10];
     69          
     70          // Event Flags
     71          #define OS_FLAGS_NBITS 8
     72          #define OS_FLAG_EN 1
     73          static OS_FLAG_GRP *flagGroup;
     74          const static OS_FLAGS FLAG_INIT = 0;
     75          const static OS_FLAGS FLAG_DETECT = 1;
     76          const static OS_FLAGS FLAG_DETECT_NOT = 2;
     77          const static OS_FLAGS FLAG_TEMPER_NORMAL = 4;
     78          const static OS_FLAGS FLAG_TEMPER_HIGH = 8;
     79          const static OS_FLAGS FLAG_TEMPER_LOW = 16;
     80          
     81          // time
     82          static OS_EVENT *sem;
     83          static int count = 0;
     84          const static int TIME_COUNT = 9; // 100ms * 10 = 1초
     85          const static int DELAY_TIME = 100;
     86          
     87          #if ((OS_PROBE_EN == DEF_ENABLED) &&  \
     88          	 (PROBE_COM_EN == DEF_ENABLED) && \
     89          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
     90          static CPU_FP32 ProbeComRxPktSpd;
     91          static CPU_FP32 ProbeComTxPktSpd;
     92          static CPU_FP32 ProbeComTxSymSpd;
     93          static CPU_FP32 ProbeComTxSymByteSpd;
     94          
     95          static CPU_INT32U ProbeComRxPktLast;
     96          static CPU_INT32U ProbeComTxPktLast;
     97          static CPU_INT32U ProbeComTxSymLast;
     98          static CPU_INT32U ProbeComTxSymByteLast;
     99          
    100          static CPU_INT32U ProbeComCtrLast;
    101          #endif
    102          
    103          #if (OS_PROBE_EN == DEF_ENABLED)
    104          static CPU_INT32U ProbeCounts;
    105          static CPU_BOOLEAN ProbeB1;
    106          
    107          #endif
    108          
    109          /*
    110           *********************************************************************************************************
    111           *                                      LOCAL FUNCTION PROTOTYPES
    112           *********************************************************************************************************
    113           */
    114          
    115          // Task function
    116          static void detectTask(void *p);
    117          static void temperTask(void *p);
    118          static void passTask(void *p);
    119          static void denyTask(void *p);
    120          static void checkTask(void *p);
    121          
    122          static void DispScr_SignOn(void);
    123          static void DispScr_TaskNames(void);
    124          
    125          static int readTemperature(void);
    126          static void stopAll();
    127          
    128          #if ((PROBE_COM_EN == DEF_ENABLED) || \
    129          	 (OS_PROBE_EN == DEF_ENABLED))
    130          static void InitProbe(void);
    131          #endif
    132          
    133          #if (OS_PROBE_EN == DEF_ENABLED)
    134          static void ProbeCallback(void);
    135          #endif
    136          
    137          /*
    138           *********************************************************************************************************
    139           *                                                main()
    140           *
    141           * Description : This is the standard entry point for C code.  It is assumed that your code will call
    142           *               main() once you have performed all necessary initialization.
    143           *
    144           * Argument(s) : none.
    145           *
    146           * Return(s)   : none.
    147           *********************************************************************************************************
    148           */
    149          
    150          int main(void)
    151          {
    152          	CPU_INT08U os_err;
    153          
    154          	/* Disable all ints until we are ready to accept them.  */
    155          	BSP_IntDisAll();
    156          
    157          	/* Initialize "uC/OS-II, The Real-Time Kernel".         */
    158          	OSInit();
    159          
    160          	// Create Message Que, msg : 저장공간, 크기 : 10
    161          	temperQue = OSQCreate(msg, 10);
    162          
    163          	// Create Event Flag
    164          	flagGroup = OSFlagCreate(FLAG_INIT, os_err);
    165          
    166          	// Create semaphore
    167          	sem = OSSemCreate(0);
    168          
    169          	os_err = OSTaskCreateExt((void (*)(void *))detectTask,						   // Task가 수행할 함수, 사람의 존재 유/무를 알려주는 Task
    170          							 (void *)0,											   // Task로 넘겨줄 인자
    171          							 (OS_STK *)&detectTaskStack[TASK_STK_SIZE - 1],		   // Task가 할당될 Stack의 Top을 가리키는 주소
    172          							 (INT8U)TASK_DETECT_PRIO,							   // Task의 우선 순위 (MPT)
    173          							 (INT16U)TASK_DETECT_PRIO,							   // Task를 지칭하는 유일한 식별자, Task 갯수의 극복을 위해서 사용할 예정, 현재는 우선 순위와 같게끔 설정
    174          							 (OS_STK *)&detectTaskStack,						   // Task가 할당될 Stack의 마지막을 가리키는 주소, Stack 검사용으로 사용
    175          							 (INT32U)TASK_STK_SIZE,								   // Task Stack의 크기를 의미
    176          							 (void *)0,											   // Task Control Block 활용시 사용
    177          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK)); // Task 생성 옵션
    178          
    179          	os_err = OSTaskCreateExt((void (*)(void *))temperTask, // 사람의 온도를 측정하여 통과할지 말지를 결정하는 Task
    180          							 (void *)0,
    181          							 (OS_STK *)&temperatureTaskStack[TASK_STK_SIZE - 1],
    182          							 (INT8U)TASK_TEMPER_PRIO,
    183          							 (INT16U)TASK_TEMPER_PRIO,
    184          							 (OS_STK *)&temperatureTaskStack,
    185          							 (INT32U)TASK_STK_SIZE,
    186          							 (void *)0,
    187          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
    188          
    189          	os_err = OSTaskCreateExt((void (*)(void *))passTask, // 정상체온인 사람은 통과를 허가하는 Task
    190          							 (void *)0,
    191          							 (OS_STK *)&passTaskStack[TASK_STK_SIZE - 1],
    192          							 (INT8U)TASK_PASS_PRIO,
    193          							 (INT16U)TASK_PASS_PRIO,
    194          							 (OS_STK *)&passTaskStack,
    195          							 (INT32U)TASK_STK_SIZE,
    196          							 (void *)0,
    197          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
    198          
    199          	os_err = OSTaskCreateExt((void (*)(void *))denyTask, // 비정상체온인 사람은 통과를 불허하는 Task
    200          							 (void *)0,
    201          							 (OS_STK *)&denyTaskStack[TASK_STK_SIZE - 1],
    202          							 (INT8U)TASK_DENY_PRIO,
    203          							 (INT16U)TASK_DENY_PRIO,
    204          							 (OS_STK *)&denyTaskStack,
    205          							 (INT32U)TASK_STK_SIZE,
    206          							 (void *)0,
    207          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
    208          
    209          	os_err = OSTaskCreateExt((void (*)(void *))checkTask, // 알림 장치 작동 중지하는 Task
    210          							 (void *)0,
    211          							 (OS_STK *)&checkTaskStack[TASK_STK_SIZE - 1],
    212          							 (INT8U)TASK_CHECK_PRIO,
    213          							 (INT16U)TASK_CHECK_PRIO,
    214          							 (OS_STK *)&checkTaskStack,
    215          							 (INT32U)TASK_STK_SIZE,
    216          							 (void *)0,
    217          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
    218          #if (OS_TASK_NAME_SIZE >= 11)
    219          	OSTaskNameSet(TASK_START_PRIO, (CPU_INT08U *)"Start Task", &os_err);
    220          #endif
    221          
    222          	OSStart(); /* Start multitasking (i.e. give control to uC/OS-II).  */
    223          
    224          	return (0);
    225          }
    226          
    227          /*
    228           *********************************************************************************************************
    229           *                                          detectTask()
    230           *
    231           * Description : Human detecting task. Monitor the existence of people,
    232           *
    233           * Argument(s) : p
    234           *
    235           * Return(s)   : none.
    236           *
    237           * Caller(s)   : This is a task.
    238           *
    239           * Note(s)     : none.
    240           *********************************************************************************************************
    241           */
    242          
    243          // Task가 수행할 함수, 사람의 존재 유/무를 알려주는 Task
    244          static void detectTask(void *p)
    245          {
    246          	CPU_INT08U err;
    247          
    248          	while (DEF_TRUE)
    249          	{
    250          		if (GPIO_ReadOutputDataBit(GPIOB, GPIO_Pin_0) != 0) // when human detected
    251          		{
    252          			OSFlagPost(flagGroup, FLAG_DETECT, OS_FLAG_SET, *err);
    253          		}
    254          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
    255          	}
    256          }
    257          
    258          /*
    259           *********************************************************************************************************
    260           *                                            temperTask()
    261           *
    262           * Description : Measure a person's temperature
    263           *
    264           * Argument(s) : p
    265           *
    266           * Return(s)   : none.
    267           *
    268           * Caller(s)   : This is a task.
    269           *
    270           * Note(s)     : none.
    271           *********************************************************************************************************
    272           */
    273          // 사람의 온도를 측정하여 통과할지 말지를 결정하는 Task
    274          static void temperTask(void *p)
    275          {
    276          	CPU_INT08U err;
    277          	int temp;
    278          	int high = 39;
    279          	int low = 34;
    280          	while (DEF_TRUE)
    281          	{
    282          		OSFlagPend(flagGroup, FLAG_DETECT, OS_FLAG_WAIT_SET_ALL + OS_FLAG_CONSUME, &err);
    283          		temp = readTemperature();
    284          		if (temp > high) // when temperature is HIGH
    285          		{
    286          			OSQPost(temperQue, temp);
    287          			OSFlagPost(flagGroup, FLAG_TEMPER_HIGH, OS_FLAG_SET, *err);
    288          		}
    289          		else if (temp < low)
    290          		{
    291          			OSQPost(temperQue, temp);
    292          			OSFlagPost(flagGroup, FLAG_TEMPER_LOW, OS_FLAG_SET, *err);
    293          		}
    294          		else
    295          		{
    296          			OSFlagPost(flagGroup, FLAG_TEMPER_NORMAL, OS_FLAG_SET, *err);
    297          		}
    298          
    299          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
    300          	}
    301          }
    302          
    303          static int readTemperature()
    304          {
    305          	CPU_INT08U high, low;
    306          	CPU_INT016U tmp = 0;
    307          
    308          	while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY))
    309          		;
    310          	I2C_GenerateSTART(I2C1, ENABLE);
    311          	while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))
    312          		;
    313          	I2C_Send7bitAddress(I2C1, addr, I2C_Direction_Transmitter);
    314          	while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
    315          		;
    316          	I2C_SendData(I2C1, 0x0);
    317          	while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
    318          		;
    319          	I2C_GenerateSTOP(I2C1, ENABLE);
    320          
    321          	I2C_GenerateSTART(I2C1, ENABLE);
    322          	while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT))
    323          		;
    324          	I2C_Send7bitAddress(I2C1, addr, I2C_Direction_Receiver);
    325          	while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
    326          		;
    327          	while ((I2C_GetLastEvent(I2C1) & I2C_FLAG_RXNE) != I2C_FLAG_RXNE)
    328          		; /* Poll on RxNE */
    329          	high = I2C_ReceiveData(I2C1);
    330          	I2C_AcknowledgeConfig(I2C1, DISABLE);
    331          	I2C_GenerateSTOP(I2C1, ENABLE);
    332          
    333          	while ((I2C_GetLastEvent(I2C1) & I2C_FLAG_RXNE) != I2C_FLAG_RXNE)
    334          		; /* Poll on RxNE */
    335          
    336          	low = I2C_ReceiveData(I2C1);
    337          	I2C_AcknowledgeConfig(I2C1, ENABLE);
    338          	tmp = (uint16_t)(high << 8);
    339          
    340          	tmp |= low;
    341          	return tmp >> 7;
    342          }
    343          
    344          /*
    345           *********************************************************************************************************
    346           *                                            passTask()
    347           *
    348           * Description : Those who are at normal body temperature are allowed to pass.
    349           *
    350           * Argument(s) : p
    351           *
    352           * Return(s)   : none.
    353           *
    354           * Caller(s)   : This is a task.
    355           *
    356           * Note(s)     : none.
    357           *********************************************************************************************************
    358           */
    359          // 정상체온인 사람은 통과를 허가하는 Task
    360          static void passTask(void *p)
    361          {
    362          	CPU_INT08U err;
    363          	while (DEF_TRUE)
    364          	{
    365          		OSFlagPend(flagGroup, FLAG_TEMPER_NORMAL, OS_FLAG_WAIT_SET_ALL + OS_FLAG_CONSUME, &err);
    366          		// dot-matrix
    367          		TODO("dot-matrix pass");
    368          		// piezo
    369          		GPIO_SetBits(GPIOB, GPIO_Pin_8);
    370          		// door
    371          		for (int i = TIM2->CCR1; i < 2300; i += 2) // 1500 -> 2300
    372          		{
    373          			TIM2->CCR1 = i;
    374          		}
    375          
    376          		// stop setting
    377          		OSSemPend(sem, 0, &err);
    378          		count = 1;
    379          		OSSemPost(sem);
    380          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
    381          	}
    382          }
    383          
    384          /*
    385           *********************************************************************************************************
    386           *                                            denyTask()
    387           *
    388           * Description : People with abnormal body temperature are not allowed to pass through.
    389           *
    390           * Argument(s) : p
    391           *
    392           * Return(s)   : none.
    393           *
    394           * Caller(s)   : This is a task.
    395           *
    396           * Note(s)     : none.
    397           *********************************************************************************************************
    398           */
    399          // 비정상체온인 사람은 통과를 불허하는 Task
    400          static void denyTask(void *p)
    401          {
    402          	CPU_INT08U err;
    403          	int temp = 0;
    404          	while (DEF_TRUE)
    405          	{
    406          		OSFlagPend(flagGroup,
    407          				   FLAG_TEMPER_HIGH + FLAG_TEMPER_LOW,
    408          				   OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
    409          				   &err);
    410          		temp = OSQPend(temperQue, 0, &err);
    411          		// dot-matrix
    412          		TODO("dot-matrix deny"); // + 온도 출력 (가능하다면) ㅋㅋ
    413          		// piezo
    414          		GPIO_SetBits(GPIOB, GPIO_Pin_8);
    415          		// Stop setting
    416          		OSSemPend(sem, 0, &err);
    417          		count = 1;
    418          		OSSemPost(sem);
    419          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
    420          	}
    421          }
    422          
    423          /*
    424           *********************************************************************************************************
    425           *                                            checkTask()
    426           *
    427           * Description : Check dot-matrix, piezo, motor.
    428           *
    429           * Argument(s) : p
    430           *
    431           * Return(s)   : none.
    432           *
    433           * Caller(s)   : This is a task.
    434           *
    435           * Note(s)     : none.
    436           *********************************************************************************************************
    437           */
    438          // dot-matrix, piezo, motor를 1초 후 정지하도록 하는 Task
    439          static void checkTask(void *p)
    440          {
    441          	CPU_INT08U err;
    442          	int isStop = 0;
    443          	while (DEF_TRUE)
    444          	{
    445          		if (count != 0)
    446          		{
    447          			OSSemPend(sem, 0, &err);
    448          			if (count > TIME_COUNT)
    449          			{
    450          				isStop = 1; // Use flag / Don't do a lot of work in sem
    451          				count = 0;	// init time counter
    452          			}
    453          			count++;
    454          			OSSemPost(sem);
    455          
    456          			// STOP: Do out of sem
    457          			if (isStop == 1)
    458          			{
    459          				stopAll();
    460          				isStop = 0;
    461          			}
    462          		}
    463          
    464          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
    465          	}
    466          }
    467          
    468          // Stop all
    469          static void stopAll()
    470          {
    471          	// dot-matrix
    472          
    473          	// piezo
    474          	GPIO_ResetBits(GPIOB, GPIO_Pin_8);
    475          	// motor
    476          	for (int i = TIM2->CCR1; i > 1500; i -= 2) // 2300 -> 1500
    477          	{
    478          		TIM2->CCR1 = i;
    479          	}
    480          }
    481          /*
    482           *********************************************************************************************************
    483           *                                          DispScr_SignOn()
    484           *
    485           * Description : Display uC/OS-II system information on the LCD.
    486           *
    487           * Argument(s) : none.
    488           *
    489           * Return(s)   : none.
    490           *
    491           * Caller(s)   : TaskUserIF().
    492           *
    493           * Note(s)     : none.
    494           *********************************************************************************************************
    495           */
    496          
    497          static void DispScr_SignOn(void)
    498          {
    499          }
    500          
    501          /*
    502           *********************************************************************************************************
    503           *                                          DispScr_SignOn()
    504           *
    505           * Description : Display uC/OS-II system information on the LCD.
    506           *
    507           * Argument(s) : none.
    508           *
    509           * Return(s)   : none.
    510           *
    511           * Caller(s)   : TaskUserIF().
    512           *
    513           * Note(s)     : none.
    514           *********************************************************************************************************
    515           */
    516          
    517          static void DispScr_TaskNames(void)
    518          {
    519          }
    520          
    521          /*
    522           *********************************************************************************************************
    523           *                                             InitProbe()
    524           *
    525           * Description : Initialize uC/Probe target code.
    526           *
    527           * Argument(s) : none.
    528           *
    529           * Return(s)   : none.
    530           *
    531           * Caller(s)   : TaskStart().
    532           *
    533           * Note(s)     : none.
    534           *********************************************************************************************************
    535           */
    536          
    537          #if ((PROBE_COM_EN == DEF_ENABLED) || \
    538          	 (OS_PROBE_EN == DEF_ENABLED))
    539          static void InitProbe(void)
    540          {
    541          #if (OS_PROBE_EN == DEF_ENABLED)
    542          	(void)ProbeCounts;
    543          	(void)ProbeB1;
    544          
    545          #if ((PROBE_COM_EN == DEF_ENABLED) && \
    546          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
    547          	(void)ProbeComRxPktSpd;
    548          	(void)ProbeComTxPktSpd;
    549          	(void)ProbeComTxSymSpd;
    550          	(void)ProbeComTxSymByteSpd;
    551          #endif
    552          
    553          	OSProbe_Init();
    554          	OSProbe_SetCallback(ProbeCallback);
    555          	OSProbe_SetDelay(250);
    556          #endif
    557          
    558          #if (PROBE_COM_EN == DEF_ENABLED)
    559          	ProbeCom_Init(); /* Initialize the uC/Probe communications module.       */
    560          #endif
    561          }
    562          #endif
    563          
    564          /*
    565           *********************************************************************************************************
    566           *                                         AppProbeCallback()
    567           *
    568           * Description : uC/Probe OS plugin callback.
    569           *
    570           * Argument(s) : none.
    571           *
    572           * Return(s)   : none.
    573           *
    574           * Caller(s)   : uC/Probe OS plugin task.
    575           *
    576           * Note(s)     : none.
    577           *********************************************************************************************************
    578           */
    579          
    580          #if (OS_PROBE_EN == DEF_ENABLED)
    581          static void ProbeCallback(void)
    582          {
    583          #if ((PROBE_COM_EN == DEF_ENABLED) && \
    584          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
    585          	CPU_INT32U ctr_curr;
    586          	CPU_INT32U rxpkt_curr;
    587          	CPU_INT32U txpkt_curr;
    588          	CPU_INT32U sym_curr;
    589          	CPU_INT32U symbyte_curr;
    590          #endif
    591          
    592          	ProbeCounts++;
    593          
    594          	ProbeB1 = BSP_PB_GetStatus(1);
    595          
    596          #if ((PROBE_COM_EN == DEF_ENABLED) && \
    597          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
    598          	ctr_curr = OSTime;
    599          	rxpkt_curr = ProbeCom_RxPktCtr;
    600          	txpkt_curr = ProbeCom_TxPktCtr;
    601          	sym_curr = ProbeCom_TxSymCtr;
    602          	symbyte_curr = ProbeCom_TxSymByteCtr;
    603          
    604          	if ((ctr_curr - ProbeComCtrLast) >= OS_TICKS_PER_SEC)
    605          	{
    606          		ProbeComRxPktSpd = ((CPU_FP32)(rxpkt_curr - ProbeComRxPktLast) / (ctr_curr - ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    607          		ProbeComTxPktSpd = ((CPU_FP32)(txpkt_curr - ProbeComTxPktLast) / (ctr_curr - ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    608          		ProbeComTxSymSpd = ((CPU_FP32)(sym_curr - ProbeComTxSymLast) / (ctr_curr - ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    609          		ProbeComTxSymByteSpd = ((CPU_FP32)(symbyte_curr - ProbeComTxSymByteLast) / (ctr_curr - ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    610          
    611          		ProbeComCtrLast = ctr_curr;
    612          		ProbeComRxPktLast = rxpkt_curr;
    613          		ProbeComTxPktLast = txpkt_curr;
    614          		ProbeComTxSymLast = sym_curr;
    615          		ProbeComTxSymByteLast = symbyte_curr;
    616          	}
    617          #endif
    618          }
    619          #endif
    620          
    621          /*
    622           *********************************************************************************************************
    623           *                                      FormatDec()
    624           *
    625           * Description : Convert a decimal value to ASCII (without leading zeros).
    626           *
    627           * Argument(s) : pstr            Pointer to the destination ASCII string.
    628           *
    629           *               value           Value to convert (assumes an unsigned value).
    630           *
    631           *               digits          The desired number of digits.
    632           *
    633           * Return(s)   : none.
    634           *
    635           * Caller(s)   : various.
    636           *
    637           * Note(s)     : none.
    638           *********************************************************************************************************
    639           */
    640          
    641          /*
    642           *********************************************************************************************************
    643           *********************************************************************************************************
    644           *                                          uC/OS-II APP HOOKS
    645           *********************************************************************************************************
    646           *********************************************************************************************************
    647           */
    648          
    649          #if (OS_HOOKS_EN > 0)
    650          /*
    651           *********************************************************************************************************
    652           *                                      TASK CREATION HOOK (APPLICATION)
    653           *
    654           * Description : This function is cal when a task is created.
    655           *
    656           * Argument(s) : ptcb   is a pointer to the task control block of the task being created.
    657           *
    658           * Note(s)     : (1) Interrupts are disabled during this call.
    659           *********************************************************************************************************
    660           */
    661          
    662          void TaskCreateHook(OS_TCB *ptcb)
    663          {
    664          #if ((OS_PROBE_EN == DEF_ENABLED) && \
    665          	 (OS_PROBE_HOOKS_EN == DEF_ENABLED))
    666          	OSProbe_TaskCreateHook(ptcb);
    667          #endif
    668          }
    669          
    670          /*
    671           *********************************************************************************************************
    672           *                                    TASK DELETION HOOK (APPLICATION)
    673           *
    674           * Description : This function is called when a task is deleted.
    675           *
    676           * Argument(s) : ptcb   is a pointer to the task control block of the task being deleted.
    677           *
    678           * Note(s)     : (1) Interrupts are disabled during this call.
    679           *********************************************************************************************************
    680           */
    681          
    682          void TaskDelHook(OS_TCB *ptcb)
    683          {
    684          	(void)ptcb;
    685          }
    686          
    687          /*
    688           *********************************************************************************************************
    689           *                                      IDLE TASK HOOK (APPLICATION)
    690           *
    691           * Description : This function is called by OSTaskIdleHook(), which is called by the idle task.  This hook
    692           *               has been added to allow you to do such things as STOP the CPU to conserve power.
    693           *
    694           * Argument(s) : none.
    695           *
    696           * Note(s)     : (1) Interrupts are enabled during this call.
    697           *********************************************************************************************************
    698           */
    699          
    700          #if OS_VERSION >= 251
    701          void TaskIdleHook(void)
    702          {
    703          }
    704          #endif
    705          
    706          /*
    707           *********************************************************************************************************
    708           *                                        STATISTIC TASK HOOK (APPLICATION)
    709           *
    710           * Description : This function is called by OSTaskStatHook(), which is called every second by uC/OS-II's
    711           *               statistics task.  This allows your application to add functionality to the statistics task.
    712           *
    713           * Argument(s) : none.
    714           *********************************************************************************************************
    715           */
    716          
    717          void TaskStatHook(void)
    718          {
    719          }
    720          
    721          /*
    722           *********************************************************************************************************
    723           *                                        TASK SWITCH HOOK (APPLICATION)
    724           *
    725           * Description : This function is called when a task switch is performed.  This allows you to perform other
    726           *               operations during a context switch.
    727           *
    728           * Argument(s) : none.
    729           *
    730           * Note(s)     : (1) Interrupts are disabled during this call.
    731           *
    732           *               (2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
    733           *                   will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
    734           *                  task being switched out (i.e. the preempted task).
    735           *********************************************************************************************************
    736           */
    737          
    738          #if OS_TASK_SW_HOOK_EN > 0
    739          void TaskSwHook(void)
    740          {
    741          #if ((OS_PROBE_EN == DEF_ENABLED) && \
    742          	 (OS_PROBE_HOOKS_EN == DEF_ENABLED))
    743          	OSProbe_TaskSwHook();
    744          #endif
    745          }
    746          #endif
    747          
    748          /*
    749           *********************************************************************************************************
    750           *                                     OS_TCBInit() HOOK (APPLICATION)
    751           *
    752           * Description : This function is called by OSTCBInitHook(), which is called by OS_TCBInit() after setting
    753           *               up most of the TCB.
    754           *
    755           * Argument(s) : ptcb    is a pointer to the TCB of the task being created.
    756           *
    757           * Note(s)     : (1) Interrupts may or may not be ENABLED during this call.
    758           *********************************************************************************************************
    759           */
    760          
    761          #if OS_VERSION >= 204
    762          void TCBInitHook(OS_TCB *ptcb)
    763          {
    764          	(void)ptcb;
    765          }
    766          #endif
    767          
    768          /*
    769           *********************************************************************************************************
    770           *                                        TICK HOOK (APPLICATION)
    771           *
    772           * Description : This function is called every tick.
    773           *
    774           * Argument(s) : none.
    775           *
    776           * Note(s)     : (1) Interrupts may or may not be ENABLED during this call.
    777           *********************************************************************************************************
    778           */
    779          
    780          #if OS_TIME_TICK_HOOK_EN > 0
    781          void TimeTickHook(void)
    782          {
    783          #if ((OS_PROBE_EN == DEF_ENABLED) && \
    784          	 (OS_PROBE_HOOKS_EN == DEF_ENABLED))
    785          	OSProbe_TickHook();
    786          #endif
    787          }
    788          #endif
    789          #endif
    790          
    791          static void Init_All()
    792          {
    793          	ADC_InitTypeDef adc_init;
    794          	GPIO_InitTypeDef gpio_init;
    795          	I2C_InitTypeDef i2c_init;
    796          	TIM_TimeBaseInitTypeDef tim_timebase_init;
    797          	TIM_OCInitTypeDef tim_piezo_init;
    798          	TIM_OCInitTypeDef tim_motor_init;
    799          	SPI_InitTypeDef spi_init;
    800          
    801          	// CLOCK
    802          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
    803          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
    804          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
    805          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
    806          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    807          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    808          
    809          	// PIN
    810          	// ADC
    811          	gpio_init.GPIO_Pin = GPIO_Pin_0;
    812          	gpio_init.GPIO_Mode = GPIO_Mode_AIN;
    813          	GPIO_Init(GPIOB, &gpio_init);
    814          	// I2C
    815          	gpio_init.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
    816          	gpio_init.GPIO_Mode = GPIO_Mode_AF_OD;
    817          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    818          	GPIO_Init(GPIOB, &gpio_init);
    819          	// TIM (PWM)
    820          	// Piezo
    821          	gpio_init.GPIO_Pin = GPIO_Pin_8;
    822          	gpio_init.GPIO_Mode = GPIO_Mode_AF_PP;
    823          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    824          	GPIO_Init(GPIOB, &gpio_init);
    825          	// Motor
    826          	gpio_init.GPIO_Pin = GPIO_Pin_9;
    827          	gpio_init.GPIO_Mode = GPIO_Mode_AF_PP;
    828          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    829          	GPIO_Init(GPIOB, &gpio_init);
    830          	// SPI
    831          	GPIO_Init(GPIOB, &gpio_init);
    832          	gpio_init.GPIO_Pin = GPIO_Pin_12;
    833          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    834          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
    835          	GPIO_Init(GPIOB, &gpio_init);
    836          	gpio_init.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
    837          	gpio_init.GPIO_Mode = GPIO_Mode_AF_PP;
    838          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    839          	GPIO_Init(GPIOB, &gpio_init);
    840          	GPIO_SetBits(GPIOB, GPIO_Pin_12) // check
    841          
    842          		// CONFIG
    843          		// ADC
    844          		adc_init.ADC_Mode = ADC_Mode_Independent;
    845          	adc_init.ADC_ScanConvMode = DISABLE;
    846          	adc_init.ADC_ContinuousConvMode = ENABLE;
    847          	adc_init.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
    848          	adc_init.ADC_DataAlign = ADC_DataAlign_Right;
    849          	adc_init.ADC_NbrOfChannel = 1;
    850          	ADC_Init(ADC1, &adc_init);
    851          	ADC_RegularChannelConfig(ADC1, ADC_Channel_14, 1, ADC_SampleTime_13Cycles5);
    852          	ADC_Cmd(ADC1, ENABLE);
    853          	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
    854          	// I2C
    855          	i2c_init.I2C_Mode = I2C_Mode_I2C;
    856          	i2c_init.I2C_DutyCycle = I2C_DutyCycle_2;
    857          	i2c_init.I2C_OwnAddress1 = 0;
    858          	i2c_init.I2C_Ack = I2C_Ack_Enable;
    859          	i2c_init.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    860          	i2c_init.I2C_ClockSpeed = 100000;
    861          	I2C_INIT(I2C1, &i2c_init);
    862          	I2C_Cmd(I2C1, ENABLE);
    863          	// TIM (PWM)
    864          	tim_timebase_init.TIM_Prescaler = (uint16_t)(72000000 / 1000000) - 1; // set to 1MHz Counter Clock
    865          	tim_timebase_init.TIM_Period = 20000 - 1;							  // set to 50Hz pulse with 1MHz Counter Clock
    866          	tim_timebase_init.TIM_ClockDivision = 0;
    867          	tim_timebase_init.TIM_CounterMode = TIM_CounterMode_Down;
    868          	tim_timebase_init.TIM_RepetitionCounter;
    869          	TIM_TimeBaseInit(TIM4, &time_timebase_init);
    870          	/* PIEZO: PWM1 Mode configuration: Channel3 */
    871          	tim_piezo_init.TIM_OCMode = TIM_OCMODE_PWM1;
    872          	tim_piezo_init.TIM_OutputState = TIM_OUTPUTSTATE_Enable;
    873          	tim_piezo_init.TIM_Pulse = 500;
    874          	tim_piezo_init.TIM_OCPolarity = TIM_OCPolarity_High;
    875          	TIM_OC3Init(TIM4, &tim_piezo_init);
    876          	//TIM_OC3PreloadConfig(TIM4, TIM_OCPreload_Disable);
    877          	TIM_Cmd(TIM4, ENABLE);
    878          	/* MOTOR: PWM1 Mode configuration: Channel4 */
    879          	tim_motor_init.TIM_OCMode = TIM_OCMODE_PWM1;
    880          	tim_motor_init.TIM_OutputState = TIM_OUTPUTSTATE_Enable;
    881          	tim_motor_init.TIM_Pulse = 1500; // 50 % duty cylce value
    882          	tim_motor_init.TIM_OCPolarity = TIM_OCPolarity_High;
    883          	TIM_PWMIConfig(TIM4, &tim_motor_init);
    884          	TIM_OC4Init(TIM4, &tim_motor_init);
    885          	TIM_OC4PreloadConfig(TIM4, TIM_OCPreload_Disable);
    886          	TIM_ARRPreloadConfig(Tim4, ENABLE);
    887          	TIM_Cmd(TIM4, ENABLE);
    888          	// SPI
    889          	spi_init.SPI_Direction = SPI_Direction_1Line_Tx;
    890          	spi_init.SPI_Mode = SPI_Mode_Master;
    891          	spi_init.SPI_DataSize = SPI_DataSize_16b;
    892          	spi_init.SPI_CPOL = SPI_CPOL_Low;
    893          	spi_init.SPI_CPHA = SPI_CPHA_1Edge;
    894          	spi_init.SPI_NSS = SPI_NSS_Soft;
    895          	spi_init.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
    896          	spi_init.SPI_FirstBit = SPI_FirstBit_MSB;
    897          	spi_init.SPI_CRCPolynomial;
    898          	SPI_Init(SPI2, &spi_init);
    899          	SPI_Cmd(SPI2, ENABLE);
    900          }

Errors: 26
Warnings: 16
